import { AddNftMinter, ApproveErc20, ApproveNftSpending, ApproveTransferCustodialWallet, ApproveTransferCustodialWalletCelo, BroadcastKMS, BurnMultiToken, BurnMultiTokenBatch, BurnNft, BuyAssetOnMarketplace, CallCeloSmartContractMethod, CallReadSmartContractMethod, CallSmartContractMethod, CancelablePromise, CancelSellAssetOnMarketplace, ChainBurnErc20 as ApiChainBurnErc20, ChainDeployErc20, ChainMintErc20 as ApiChainMintErc20, ChainTransferEthErc20, Currency, DeployMultiToken, DeployNft, ExchangeRate, Fiat, GenerateCustodialWallet, GenerateCustodialWalletBatch, GenerateCustodialWalletBatchCelo, GenerateCustodialWalletBatchCeloKMS, GenerateCustodialWalletBatchKMS, GenerateCustodialWalletBatchPayer, GenerateCustodialWalletCelo, GenerateMarketplace, MarketplaceService, MintMultipleNft, MintMultiToken, MintMultiTokenBatch, MintNft, PendingTransaction, SellAssetOnMarketplace, SignatureId, TatumUrlArg, TransactionHash, TransferCustodialWallet, TransferCustodialWalletBatch, TransferCustodialWalletBatchCelo, TransferCustodialWalletCelo, TransferCustodialWalletCeloKMS, TransferCustodialWalletKMS, TransferMultiToken, TransferMultiTokenBatch, TransferNft, TransferPolygonBlockchain, UpdateFee, UpdateFeeRecipient, XlmWallet, XrpWallet } from '@tatumio/api-client';
import { Blockchain } from '@tatumio/shared-core';
import { WithoutChain } from '@tatumio/shared-abstract-sdk';
export declare const abstractBlockchainSdk: (args: {
    apiKey: string;
    url?: TatumUrlArg;
    blockchain: Blockchain;
}) => {
    kms: {
        getAllPending(signatures?: string): CancelablePromise<PendingTransaction[]>;
        get: typeof import("@tatumio/api-client").KeyManagementSystemService.getPendingTransactionToSign;
        complete: typeof import("@tatumio/api-client").KeyManagementSystemService.completePendingSignature;
        delete: typeof import("@tatumio/api-client").KeyManagementSystemService.deletePendingTransactionToSign;
    };
    virtualAccount: {
        depositAddress: {
            checkExists: (address: string, index?: number) => Promise<import("@tatumio/api-client").Account>;
            create: typeof import("@tatumio/api-client").BlockchainAddressesService.generateDepositAddress;
            createMultiple: typeof import("@tatumio/api-client").BlockchainAddressesService.generateDepositAddressesBatch;
            assign: typeof import("@tatumio/api-client").BlockchainAddressesService.assignAddress;
            remove: typeof import("@tatumio/api-client").BlockchainAddressesService.removeAddress;
            getByAccount: typeof import("@tatumio/api-client").BlockchainAddressesService.getAllDepositAddresses;
        };
        withdrawal: {
            getAll: (status?: "InProgress" | "Done" | "Cancelled", pageSize?: number, offset?: number) => Promise<import("@tatumio/api-client").WithdrawalObject[]>;
            broadcast: typeof import("@tatumio/api-client").WithdrawalService.broadcastBlockchainTransaction;
            create: typeof import("@tatumio/api-client").WithdrawalService.storeWithdrawal;
            complete: typeof import("@tatumio/api-client").WithdrawalService.completeWithdrawal;
        };
        storeTokenAddress: typeof import("@tatumio/api-client").BlockchainOperationsService.storeTokenAddress;
    };
    getExchangeRate(basePair?: Fiat): CancelablePromise<ExchangeRate>;
    subscriptions: typeof import("@tatumio/api-client").NotificationSubscriptionsService;
    security: {
        checkMaliciousAddress: typeof import("@tatumio/api-client").MaliciousAddressService.checkMalicousAddress;
    };
    tatum: {
        getCredits: typeof import("@tatumio/api-client").ServiceUtilsService.getCredits;
        getVersion: typeof import("@tatumio/api-client").ServiceUtilsService.getVersion;
        freezeApiKey: typeof import("@tatumio/api-client").ServiceUtilsService.freezeApiKey;
        unfreezeApiKey: typeof import("@tatumio/api-client").ServiceUtilsService.unfreezeApiKey;
    };
    ledger: {
        customer: {
            get: typeof import("@tatumio/api-client").CustomerService.getCustomerByExternalOrInternalId;
            getAll: typeof import("@tatumio/api-client").CustomerService.findAllCustomers;
            update: typeof import("@tatumio/api-client").CustomerService.updateCustomer;
            activate: typeof import("@tatumio/api-client").CustomerService.activateCustomer;
            deactivate: typeof import("@tatumio/api-client").CustomerService.deactivateCustomer;
            enable: typeof import("@tatumio/api-client").CustomerService.enableCustomer;
            disable: typeof import("@tatumio/api-client").CustomerService.disableCustomer;
        };
        orderBook: {
            getHistorical: typeof import("@tatumio/api-client").OrderBookService.getHistoricalTradesBody;
            getActiveBuyTrades: typeof import("@tatumio/api-client").OrderBookService.getBuyTradesBody;
            getActiveSellTrades: typeof import("@tatumio/api-client").OrderBookService.getSellTradesBody;
            newTrade: typeof import("@tatumio/api-client").OrderBookService.storeTrade;
            get: typeof import("@tatumio/api-client").OrderBookService.getTradeById;
            cancel: typeof import("@tatumio/api-client").OrderBookService.deleteTrade;
            cancelByAccount: typeof import("@tatumio/api-client").OrderBookService.deleteAccountTrades;
        };
        transaction: {
            send: typeof import("@tatumio/api-client").TransactionService.sendTransaction;
            sendMultiple: typeof import("@tatumio/api-client").TransactionService.sendTransactionBatch;
            getAll: typeof import("@tatumio/api-client").TransactionService.getTransactions;
            getAllByAccount: typeof import("@tatumio/api-client").TransactionService.getTransactionsByAccountId;
            getAllByCustomer: typeof import("@tatumio/api-client").TransactionService.getTransactionsByCustomerId;
            getAllByReference: typeof import("@tatumio/api-client").TransactionService.getTransactionsByReference;
            countByAccount: (filter: import("@tatumio/api-client").TransactionFilter) => CancelablePromise<number | import("@tatumio/api-client").Transaction[]>;
            countByCustomer: (filter: import("@tatumio/api-client").TransactionFilterCustomer) => CancelablePromise<number | import("@tatumio/api-client").Transaction[]>;
        };
        virtualCurrency: {
            create: typeof import("@tatumio/api-client").VirtualCurrencyService.createCurrency;
            mint: typeof import("@tatumio/api-client").VirtualCurrencyService.mintCurrency;
            revoke: typeof import("@tatumio/api-client").VirtualCurrencyService.revokeCurrency;
            getByName: typeof import("@tatumio/api-client").VirtualCurrencyService.getCurrency;
            update: typeof import("@tatumio/api-client").VirtualCurrencyService.updateCurrency;
        };
        blockAmount: {
            block: typeof import("@tatumio/api-client").AccountService.blockAmount;
            unblock: typeof import("@tatumio/api-client").AccountService.deleteBlockAmount;
            unblockWithTransaction: typeof import("@tatumio/api-client").AccountService.unblockAmountWithTransaction;
        };
        account: {
            get: typeof import("@tatumio/api-client").AccountService.getAccountByAccountId;
            getAll: typeof import("@tatumio/api-client").AccountService.getAccounts;
            getByCustomerId: typeof import("@tatumio/api-client").AccountService.getAccountsByCustomerId;
            getBalance: typeof import("@tatumio/api-client").AccountService.getAccountBalance;
            create: typeof import("@tatumio/api-client").AccountService.createAccount;
            createMultiple: typeof import("@tatumio/api-client").AccountService.createAccountBatch;
            update: typeof import("@tatumio/api-client").AccountService.updateAccountByAccountId;
            getBlockedAmountsByAccountId: typeof import("@tatumio/api-client").AccountService.getBlockAmountById;
            activate: typeof import("@tatumio/api-client").AccountService.activateAccount;
            deactivate: typeof import("@tatumio/api-client").AccountService.deactivateAccount;
            freeze: typeof import("@tatumio/api-client").AccountService.freezeAccount;
            unfreeze: typeof import("@tatumio/api-client").AccountService.unfreezeAccount;
            generate: (account: import("@tatumio/api-client").CreateAccount & {
                xpub?: string;
            }, generateNewWalletFn: import("@tatumio/shared-abstract-sdk").GenerateWalletFn, generateNewWallet?: boolean, testnet?: boolean, webhookUrl?: string) => Promise<import("@tatumio/shared-abstract-sdk").GeneratedAccount>;
        };
    };
};
export interface SdkWithXrpLikeWalletFunction {
    wallet(): XrpWallet | XlmWallet;
    isValidAddress(address: string): boolean;
    isValidSecret(secret: string): boolean;
}
export declare type FromSecretOrSignatureId<T extends {
    fromSecret?: string;
}> = Omit<T, 'fromSecret'> & Partial<SignatureId> & Partial<Pick<T, 'fromSecret'>>;
export declare type SecretOrSignatureId<T extends {
    secret?: string;
}> = Omit<T, 'secret'> & Partial<SignatureId> & Partial<Pick<T, 'secret'>>;
export declare type FromPrivateKeyOrSignatureId<T extends {
    fromPrivateKey?: string;
}> = Omit<T, 'fromPrivateKey'> & Partial<SignatureId & {
    index: number;
}> & Partial<Pick<T, 'fromPrivateKey'>> & Partial<{
    mnemonic: string;
}>;
export declare type PrivateKeyOrSignatureId<T extends {
    privateKey?: string;
}> = Omit<T, 'privateKey'> & Partial<SignatureId & {
    index: number;
}> & Partial<Pick<T, 'privateKey'>> & Partial<{
    mnemonic: string;
}>;
export declare type FromPrivateKeyOrSignatureIdTron<T extends {
    fromPrivateKey?: string;
}> = Omit<T, 'fromPrivateKey'> & Partial<SignatureId & {
    index: number;
    account: string;
    from: string;
}> & Partial<Pick<T, 'fromPrivateKey'>>;
export declare type ChainTransferErc20 = FromPrivateKeyOrSignatureId<WithoutChain<ChainTransferEthErc20>>;
export declare type ChainMintErc20 = FromPrivateKeyOrSignatureId<WithoutChain<ApiChainMintErc20>>;
export declare type ChainBurnErc20 = FromPrivateKeyOrSignatureId<WithoutChain<ApiChainBurnErc20>>;
export declare type ChainApproveErc20 = FromPrivateKeyOrSignatureId<WithoutChain<ApproveErc20>>;
export declare type ChainSdkDeployErc20 = FromPrivateKeyOrSignatureId<WithoutChain<ChainDeployErc20>>;
export declare type ChainMintErc721 = FromPrivateKeyOrSignatureId<WithoutChain<MintNft>>;
export declare type ChainMintMultipleNft = FromPrivateKeyOrSignatureId<WithoutChain<MintMultipleNft>>;
export declare type ChainBurnErc721 = FromPrivateKeyOrSignatureId<WithoutChain<BurnNft>>;
export declare type ChainAddMinterErc721 = FromPrivateKeyOrSignatureId<WithoutChain<AddNftMinter>>;
export declare type ChainTransferErc721 = FromPrivateKeyOrSignatureId<WithoutChain<TransferNft>>;
export declare type ChainDeployErc721 = FromPrivateKeyOrSignatureId<WithoutChain<DeployNft>>;
export declare type ChainBurnMultiToken = FromPrivateKeyOrSignatureId<WithoutChain<BurnMultiToken>>;
export declare type ChainBurnMultiTokenBatch = FromPrivateKeyOrSignatureId<WithoutChain<BurnMultiTokenBatch>>;
export declare type ChainTransferMultiToken = FromPrivateKeyOrSignatureId<WithoutChain<TransferMultiToken>>;
export declare type ChainTransferMultiTokenBatch = FromPrivateKeyOrSignatureId<WithoutChain<TransferMultiTokenBatch>>;
export declare type ChainMintMultiToken = FromPrivateKeyOrSignatureId<WithoutChain<MintMultiToken>>;
export declare type ChainMintMultiTokenBatch = FromPrivateKeyOrSignatureId<WithoutChain<MintMultiTokenBatch>>;
export declare type ChainDeployMultiToken = FromPrivateKeyOrSignatureId<WithoutChain<DeployMultiToken>>;
export declare type ChainSmartContractMethodInvocation = FromPrivateKeyOrSignatureId<CallSmartContractMethod> & {
    index?: number;
};
export declare type ChainGenerateCustodialAddress = FromPrivateKeyOrSignatureId<GenerateCustodialWallet> | FromPrivateKeyOrSignatureId<GenerateCustodialWalletCelo>;
export declare type ChainTransferNative = FromPrivateKeyOrSignatureId<Omit<TransferPolygonBlockchain, 'currency'>> & {
    gas?: string;
    currency?: Currency;
};
export declare type ChainGenerateMarketplace = FromPrivateKeyOrSignatureId<GenerateMarketplace>;
export declare type ChainUpdateFee = FromPrivateKeyOrSignatureId<UpdateFee>;
export declare type ChainUpdateFeeRecipient = FromPrivateKeyOrSignatureId<UpdateFeeRecipient>;
export declare type ChainBuyAssetOnMarketplace = FromPrivateKeyOrSignatureId<BuyAssetOnMarketplace>;
export declare type ChainSellAssetOnMarketplace = FromPrivateKeyOrSignatureId<SellAssetOnMarketplace>;
export declare type ChainCancelSellAssetOnMarketplace = FromPrivateKeyOrSignatureId<CancelSellAssetOnMarketplace>;
export declare type ChainTransferCustodialWallet = (FromPrivateKeyOrSignatureId<TransferCustodialWallet> & {
    index?: number;
}) | (FromPrivateKeyOrSignatureId<TransferCustodialWalletCelo> & {
    index?: number;
});
export declare type ChainBatchTransferCustodialWallet = (FromPrivateKeyOrSignatureId<TransferCustodialWalletBatch> & {
    index?: number;
}) | (FromPrivateKeyOrSignatureId<TransferCustodialWalletBatchCelo> & {
    index?: number;
});
export declare type ChainApproveCustodialTransfer = (FromPrivateKeyOrSignatureId<ApproveTransferCustodialWallet> & {
    index?: number;
}) | (FromPrivateKeyOrSignatureId<ApproveTransferCustodialWalletCelo> & {
    index?: number;
});
export declare type ChainTransferFromCustodialAddress = TransferCustodialWalletKMS | TransferCustodialWallet | TransferCustodialWalletCelo | TransferCustodialWalletCeloKMS;
export declare type ChainGenerateCustodialWalletBatch = GenerateCustodialWalletBatchPayer | GenerateCustodialWalletBatch | GenerateCustodialWalletBatchKMS | GenerateCustodialWalletBatchCelo | GenerateCustodialWalletBatchCeloKMS;
export declare type ChainCallSmartContractMethod = (FromPrivateKeyOrSignatureId<CallSmartContractMethod> & {
    index?: number;
}) | (FromPrivateKeyOrSignatureId<CallCeloSmartContractMethod> & {
    index?: number;
    chain: 'CELO';
});
export declare type ChainTransferCustodialWalletCelo = FromPrivateKeyOrSignatureId<TransferCustodialWalletCelo> & {
    index?: number;
};
export interface SdkWithErc20Functions {
    decimals(contractAddress: string, provider?: string): any;
    prepare: {
        deploySignedTransaction(body: ChainSdkDeployErc20, provider?: string): Promise<string>;
        transferSignedTransaction(body: ChainTransferErc20, provider?: string): Promise<string>;
        mintSignedTransaction(body: ChainMintErc20, provider?: string): Promise<string>;
        approveSignedTransaction(body: ChainApproveErc20, provider?: string): Promise<string>;
        burnSignedTransaction(body: ChainBurnErc20, provider?: string): Promise<string>;
    };
}
export interface SdkWithNativeFunctions {
    prepare: {
        transferSignedTransaction(body: ChainTransferNative, provider?: string): Promise<string>;
    };
}
export interface SdkWithErc721Functions {
    prepare: {
        deploySignedTransaction(body: ChainDeployErc721, provider?: string): Promise<string>;
        transferSignedTransaction(body: ChainTransferErc721, provider?: string): Promise<string>;
        mintSignedTransaction(body: ChainMintErc721, provider?: string): Promise<string>;
        burnSignedTransaction(body: ChainBurnErc721, provider?: string): Promise<string>;
        mintMultipleSignedTransaction(body: ChainMintMultipleNft, provider?: string): Promise<string>;
    };
}
export interface SdkWithMultiTokenFunctions {
    prepare: {
        mintMultiTokenTransaction(body: ChainMintMultiToken, provider?: string): Promise<string>;
        mintMultiTokenBatchTransaction(body: ChainMintMultiTokenBatch, provider?: string): Promise<string>;
        transferMultiTokenTransaction(body: ChainTransferMultiToken, provider?: string): Promise<string>;
        transferMultiTokenBatchTransaction(body: ChainTransferMultiTokenBatch, provider?: string): Promise<string>;
        deployMultiTokenTransaction(body: ChainDeployMultiToken, provider?: string): Promise<string>;
        burnMultiTokenTransaction(body: ChainBurnMultiToken, provider?: string): Promise<string>;
        burnMultiTokenBatchTransaction(body: ChainBurnMultiTokenBatch, provider?: string): Promise<string>;
    };
}
export interface SdkWithSmartContractFunctions {
    prepare: {
        smartContractWriteMethodInvocationTransaction(body: ChainSmartContractMethodInvocation, provider?: string): Promise<string>;
    };
    send: {
        smartContractReadMethodInvocationTransaction(body: CallReadSmartContractMethod, provider?: string): Promise<{
            data: any;
        }>;
    };
}
export interface SdkWithCustodialFunctions {
    prepare: {
        transferFromCustodialWallet(body: ChainTransferCustodialWallet, provider?: string, testnet?: boolean): Promise<string>;
        batchTransferFromCustodialWallet: (body: ChainBatchTransferCustodialWallet, provider?: string, testnet?: boolean) => Promise<string>;
        approveFromCustodialWallet: (body: ChainApproveCustodialTransfer, provider?: string) => Promise<string>;
        custodialWalletBatch: (body: ChainGenerateCustodialWalletBatch, provider?: string, testnet?: boolean) => Promise<string>;
    };
}
export interface SdkWithMarketplaceFunctions {
    prepare: {
        approveErc20Spending(body: FromPrivateKeyOrSignatureId<ApproveErc20>, provider?: string): Promise<string>;
        approveSpending(body: FromPrivateKeyOrSignatureId<ApproveNftSpending>, provider?: string): Promise<string>;
        generateMarketplace(body: ChainGenerateMarketplace, provider?: string): Promise<string>;
        updateFee(body: ChainUpdateFee, provider?: string): Promise<string>;
        updateFeeRecipient(body: ChainUpdateFeeRecipient, provider?: string): Promise<string>;
        buyMarketplaceListing(body: ChainBuyAssetOnMarketplace, provider?: string): Promise<string>;
        sellMarketplaceListing(body: ChainSellAssetOnMarketplace, provider?: string): Promise<string>;
        cancelMarketplaceListing(body: ChainCancelSellAssetOnMarketplace, provider?: string): Promise<string>;
    };
    getMarketplaceListing: typeof MarketplaceService.getMarketplaceListing;
    getMarketplaceListings: typeof MarketplaceService.getMarketplaceListings;
    getMarketplaceFee: typeof MarketplaceService.getMarketplaceFee;
    getMarketplaceFeeRecipient: typeof MarketplaceService.getMarketplaceFeeRecipient;
}
export interface SdkWithKmsFunctions {
    sign(tx: PendingTransaction, fromPrivateKey: string, provider?: string): Promise<string>;
    getAllPending(signatures?: string): CancelablePromise<PendingTransaction[]>;
    get(id: string): CancelablePromise<PendingTransaction>;
}
export declare type BroadcastFunction = (requestBody: BroadcastKMS) => CancelablePromise<TransactionHash>;
