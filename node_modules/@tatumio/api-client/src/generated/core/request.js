"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.http = exports.httpFetch = exports.httpAxios = exports.request = void 0;
const tslib_1 = require("tslib");
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
const axios_1 = tslib_1.__importDefault(require("axios"));
//import Blob from 'cross-blob'
const form_data_1 = tslib_1.__importDefault(require("form-data"));
const ApiError_1 = require("./ApiError");
const CancelablePromise_1 = require("./CancelablePromise");
const OpenAPI_1 = require("./OpenAPI");
const package_json_1 = require("../../../package.json");
const isWebWorker = typeof self === 'object' &&
    self.constructor &&
    ['DedicatedWorkerGlobalScope', 'ServiceWorkerGlobalScope'].includes(self.constructor.name);
const axiosInstance = axios_1.default.create();
function isDefined(value) {
    return value !== undefined && value !== null;
}
function isString(value) {
    return typeof value === 'string';
}
function isStringWithValue(value) {
    return isString(value) && value !== '';
}
const isBlob = (value) => {
    return (typeof value === 'object' &&
        typeof value.type === 'string' &&
        typeof value.stream === 'function' &&
        typeof value.arrayBuffer === 'function' &&
        typeof value.constructor === 'function' &&
        typeof value.constructor.name === 'string' &&
        /^(Blob|File)$/.test(value.constructor.name) &&
        /^(Blob|File)$/.test(value[Symbol.toStringTag]));
};
function isFile(value) {
    return typeof value.name === 'string' && typeof value.lastModified === 'number' && isBlob(value);
}
function isSuccess(status) {
    return status >= 200 && status < 300;
}
function base64(str) {
    try {
        return btoa(str);
    }
    catch (err) {
        return Buffer.from(str).toString('base64');
    }
}
function getQueryString(params) {
    const qs = [];
    const append = (key, value) => {
        qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
    };
    Object.entries(params)
        .filter(([_, value]) => isDefined(value))
        .forEach(([key, value]) => {
        if (Array.isArray(value)) {
            value.forEach((v) => append(key, v));
        }
        else {
            append(key, value);
        }
    });
    if (qs.length > 0) {
        return `?${qs.join('&')}`;
    }
    return '';
}
function getUrl(options) {
    const path = OpenAPI_1.OpenAPI.ENCODE_PATH ? OpenAPI_1.OpenAPI.ENCODE_PATH(options.path) : options.path;
    const url = `${OpenAPI_1.OpenAPI.BASE}${path}`;
    if (options.query) {
        return `${url}${getQueryString(options.query)}`;
    }
    return url;
}
function getFormData(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (options.formData) {
            const formData = new form_data_1.default();
            const append = (key, value) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (isBlob(value) || isFile(value)) {
                    const buffer = Buffer.from(yield value.arrayBuffer());
                    formData.append(key, buffer, isFile(value) ? value.name : undefined);
                }
                else if (isString(value)) {
                    formData.append(key, value);
                }
                else {
                    formData.append(key, JSON.stringify(value));
                }
            });
            Object.entries(options.formData)
                .filter(([_, value]) => isDefined(value))
                .forEach(([key, value]) => {
                if (Array.isArray(value)) {
                    value.forEach((v) => append(key, v));
                }
                else {
                    append(key, value);
                }
            });
            return formData;
        }
        return;
    });
}
function resolve(options, resolver) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (typeof resolver === 'function') {
            return resolver(options);
        }
        return resolver;
    });
}
function getHeaders(options, formData) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const token = yield resolve(options, OpenAPI_1.OpenAPI.TOKEN);
        const username = yield resolve(options, OpenAPI_1.OpenAPI.USERNAME);
        const password = yield resolve(options, OpenAPI_1.OpenAPI.PASSWORD);
        const additionalHeaders = yield resolve(options, OpenAPI_1.OpenAPI.HEADERS);
        const formHeaders = (typeof (formData === null || formData === void 0 ? void 0 : formData.getHeaders) === 'function' && (formData === null || formData === void 0 ? void 0 : formData.getHeaders())) || {};
        const headers = Object.entries(Object.assign(Object.assign(Object.assign({ Accept: 'application/json', 'User-Agent': `Tatum_SDK_JS/${package_json_1.version}` }, additionalHeaders), options.headers), formHeaders))
            .filter(([_, value]) => isDefined(value))
            .reduce((headers, [key, value]) => (Object.assign(Object.assign({}, headers), { [key]: String(value) })), {});
        if (isStringWithValue(token)) {
            headers['Authorization'] = `Bearer ${token}`;
        }
        if (isStringWithValue(username) && isStringWithValue(password)) {
            const credentials = base64(`${username}:${password}`);
            headers['Authorization'] = `Basic ${credentials}`;
        }
        return headers;
    });
}
function getRequestBody(options) {
    if (options.body) {
        return options.body;
    }
    return;
}
function sendRequest(options, url, formData, body, headers, onCancel) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const source = axios_1.default.CancelToken.source();
        const config = {
            url,
            headers,
            data: body || formData,
            method: options.method,
            withCredentials: OpenAPI_1.OpenAPI.WITH_CREDENTIALS,
            cancelToken: source.token,
        };
        if (onCancel)
            onCancel(() => source.cancel('The user aborted a request.'));
        try {
            return yield axiosInstance.request(config);
        }
        catch (error) {
            const axiosError = error;
            if (axiosError.response) {
                return axiosError.response;
            }
            throw error;
        }
    });
}
function getResponseHeaderAxios(response, responseHeader) {
    if (responseHeader) {
        const content = response.headers[responseHeader];
        if (isString(content)) {
            return content;
        }
    }
    return;
}
function getResponseHeaderFetch(response, responseHeader) {
    if (responseHeader) {
        const content = response.headers.get(responseHeader);
        if (isString(content)) {
            return content;
        }
    }
    return;
}
function getResponseBody(response) {
    if (response.status !== 204) {
        return response.data;
    }
    return;
}
function catchErrors(options, result) {
    const errors = Object.assign({ 400: 'Bad Request', 401: 'Unauthorized', 403: 'Forbidden', 404: 'Not Found', 500: 'Internal Server Error', 502: 'Bad Gateway', 503: 'Service Unavailable' }, options.errors);
    const error = errors[result.status];
    if (error) {
        throw new ApiError_1.ApiError(result, error);
    }
    if (!result.ok) {
        throw new ApiError_1.ApiError(result, 'Generic Error');
    }
}
function request(options) {
    return new CancelablePromise_1.CancelablePromise((resolve, reject, onCancel) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const url = getUrl(options);
            const formData = yield getFormData(options);
            const body = getRequestBody(options);
            const headers = yield getHeaders(options, formData);
            if (!onCancel.isCancelled) {
                const result = yield (0, exports.http)({ options, url, formData, body, headers, onCancel });
                catchErrors(options, result);
                resolve(result.body);
            }
        }
        catch (error) {
            reject(error);
        }
    }));
}
exports.request = request;
const httpAxios = ({ options, url, formData, body, headers, onCancel }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const response = yield sendRequest(options, url, formData, body, headers, onCancel);
    const responseBody = getResponseBody(response);
    const responseHeader = getResponseHeaderAxios(response, options.responseHeader);
    const result = {
        url,
        ok: isSuccess(response.status),
        status: response.status,
        statusText: response.statusText,
        body: responseHeader || responseBody,
    };
    return result;
});
exports.httpAxios = httpAxios;
const httpFetch = ({ options, url, formData, body, headers, onCancel }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const response = yield fetch(url, {
        method: options.method,
        headers: Object.assign(Object.assign({}, headers), { 'Content-Type': 'application/json' }),
        body: JSON.stringify(body) || JSON.stringify(formData),
        credentials: OpenAPI_1.OpenAPI.WITH_CREDENTIALS ? 'include' : 'omit',
    });
    const responseBody = yield response.json();
    const responseHeader = getResponseHeaderFetch(response, options.responseHeader);
    const result = {
        url,
        ok: isSuccess(response.status),
        status: response.status,
        statusText: response.statusText,
        body: responseHeader || responseBody,
    };
    return result;
});
exports.httpFetch = httpFetch;
const http = (http) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return isWebWorker ? (0, exports.httpFetch)(http) : (0, exports.httpAxios)(http); });
exports.http = http;
//# sourceMappingURL=request.js.map