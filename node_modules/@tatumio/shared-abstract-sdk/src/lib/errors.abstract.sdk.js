"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdkErrorMessage = exports.SdkErrorCode = exports.SdkError = exports.isSdkError = void 0;
const utils_1 = require("./utils");
function stringifyError(errorCode, errorMessage, originalError) {
    return JSON.stringify({
        errorCode,
        errorMessage,
        originalError,
    }, null, 2);
}
function isApiError(args) {
    var _a;
    return args.originalError && 'name' in args.originalError && ((_a = args.originalError) === null || _a === void 0 ? void 0 : _a.name) === 'ApiError'; // bypassing jest mock
}
function isSdkError(error) {
    return error instanceof SdkError;
}
exports.isSdkError = isSdkError;
class SdkError extends Error {
    constructor(args) {
        var _a, _b, _c;
        let errorCode;
        let originalError;
        let errorMessage;
        if ('code' in args) {
            errorCode = args.code;
            if (args.originalError) {
                errorMessage = errorMessage = (_a = args === null || args === void 0 ? void 0 : args.originalError) === null || _a === void 0 ? void 0 : _a.message;
            }
            else {
                errorMessage = (0, utils_1.placeArgsToString)(exports.SdkErrorMessage.get(errorCode), args.messageArgs);
            }
        }
        else {
            if (args.originalError instanceof SdkError) {
                errorCode = args.originalError.errorCode;
                originalError = args.originalError.originalError;
                errorMessage = args.originalError.errorMessage;
            }
            else if (isApiError(args)) {
                errorCode = SdkErrorCode.API_ERROR;
                errorMessage = exports.SdkErrorMessage.get(errorCode);
                originalError = args.originalError;
            }
            else {
                const errorMessageAsString = args.originalErrorAsString
                    ? args.originalErrorAsString
                    : (_b = args.originalError) === null || _b === void 0 ? void 0 : _b.toString();
                if (args.errorSubstringMapping) {
                    const errorCodeFromMapping = args.errorSubstringMapping
                        ? Object.keys(args.errorSubstringMapping).find((k) => errorMessageAsString && errorMessageAsString.indexOf(k) !== -1)
                        : undefined;
                    errorCode = errorCodeFromMapping
                        ? args.errorSubstringMapping[errorCodeFromMapping]
                        : SdkErrorCode.COMMON_ERROR;
                }
                else {
                    errorCode = SdkErrorCode.COMMON_ERROR;
                }
                originalError = (_c = args === null || args === void 0 ? void 0 : args.originalError) === null || _c === void 0 ? void 0 : _c.message;
                errorMessage = exports.SdkErrorMessage.get(errorCode);
            }
        }
        super(stringifyError(errorCode, errorMessage, originalError));
        this.errorCode = errorCode;
        this.errorMessage = errorMessage;
        this.originalError = originalError;
    }
}
exports.SdkError = SdkError;
var SdkErrorCode;
(function (SdkErrorCode) {
    SdkErrorCode["API_ERROR"] = "api.error";
    SdkErrorCode["COMMON_ERROR"] = "sdk.common.error";
    SdkErrorCode["BTC_BASED_FEE_TOO_SMALL"] = "btc-based.fee.too-small";
    SdkErrorCode["BTC_BASED_UTXO_NOT_FOUND"] = "btc-based.utxo.not-found";
    SdkErrorCode["BTC_BASED_NO_INPUTS"] = "btc-based.no.inputs";
    SdkErrorCode["BTC_BASED_NOT_ENOUGH_BALANCE"] = "btc-based.balance.not-enough";
    SdkErrorCode["BTC_FEE_IS_TOO_LARGE"] = "btc-based.fee.too-large";
    SdkErrorCode["XRP_SECRET_DOES_NOT_MATCH"] = "xrp.secret.does-not-match";
    SdkErrorCode["FEE_TOO_SMALL"] = "fee.too-small";
    SdkErrorCode["TX_NOT_FOUND"] = "tx.not.found";
    SdkErrorCode["ADA_BASED_AMOUNT"] = "ada.validation.amount";
    SdkErrorCode["BTC_BASED_AMOUNT"] = "btc-based.validation.amount";
    SdkErrorCode["BTC_BASED_MISSING_PRIVATE_KEY"] = "btc-based.validation.private-key.missing";
    SdkErrorCode["BTC_BASED_WRONG_PRIVATE_KEY"] = "btc-based.validation.private-key.wrong";
    SdkErrorCode["BTC_BASED_WRONG_BODY"] = "btc-based.validation.body.wrong-body";
    SdkErrorCode["BTC_BASED_TX_PREPARATION_UTXO"] = "transaction.preparation.failed.utxo";
    SdkErrorCode["BTC_BASED_DESTINATION_LESS_THAN_ZERO"] = "transaction.preparation.destination.less.than.zero";
    SdkErrorCode["BTC_BASED_MNEMONIC_OR_KEYPAIR_EXPECTED"] = "transaction.preparation.mnemonic.or.keypair.not.present";
    SdkErrorCode["BTC_BASED_TX_FAILED"] = "transaction.preparation.failed";
    SdkErrorCode["BTC_BASED_BLOCKCHAIN_ERROR"] = "transaction.preparation.blockchain.error";
    SdkErrorCode["BTC_BASED_DUST_AMOUNT"] = "transaction.output.dust.amount";
    SdkErrorCode["VALIDATION_AMOUNT"] = "validation.amount";
    SdkErrorCode["SECRET_CHECKSUM"] = "validation.secret.checksum";
    SdkErrorCode["VALIDATION_TO_ADDRESS"] = "validation.to-address";
    SdkErrorCode["TX_PREPARATION_FAILED"] = "tx.preparation";
    // CARDANO
    SdkErrorCode["FEE_CHANGE_ADDRESS"] = "fee.change-address";
    // XLM
    SdkErrorCode["XLM_NO_SEQUENCE"] = "xlm.account.no-sequence";
    // FLOW
    SdkErrorCode["FLOW_MISSING_PRIVATE_KEY"] = "flow.private-key.missing";
    SdkErrorCode["FLOW_MISSING_MNEMONIC"] = "flow.mnemonic.missing";
    SdkErrorCode["FLOW_MISSING_NETWORK"] = "flow.network.missing";
    // CELO
    SdkErrorCode["CELO_MISSING_CURRENCY"] = "celo.missing.currency";
    SdkErrorCode["CELO_MISSING_CONTRACT_ADDRESS"] = "celo.missing.contract-address";
    SdkErrorCode["CELO_NATIVE_CANNOT_PREPARE_TRANSFER_CELO_OR_CUSD_TX"] = "celo.native.cannot.prepare.transfer-celo-or-cusd-tx";
    // SOLANA
    SdkErrorCode["SOLANA_KMS_COMBINATION"] = "solana.kms.combination";
    SdkErrorCode["SOLANA_DECIMAL_PLACES"] = "solana.amount.decimals";
    // ALGO
    SdkErrorCode["ALGO_TOKEN_NAME_TOO_LONG"] = "algo.token.name.too-long";
    // EVM General
    SdkErrorCode["EVM_CANNOT_SIGN_TRANSACTION"] = "evm-based.cannot.sign-transaction";
    SdkErrorCode["EVM_CANNOT_ESTIMATE_GAS_LIMIT"] = "evm-based.cannot.estimate-gas-limit";
    SdkErrorCode["EVM_INVALID_ADDRESS_SINGLE"] = "evm-based.invalid.single-address";
    SdkErrorCode["EVM_INVALID_ADDRESS_ARRAY"] = "evm-based.invalid.array-address";
    // EVM Native
    SdkErrorCode["EVM_NATIVE_CANNOT_PREPARE_TRANSFER_TX"] = "evm-based.native.cannot.prepare.transfer-tx";
    SdkErrorCode["EVM_NATIVE_CANNOT_PREPARE_STORE_DATA_TX"] = "evm-based.native.cannot.prepare.store-data-tx";
    // ERC20
    SdkErrorCode["EVM_ERC20_CANNOT_PREPARE_DEPLOY_TX"] = "evm-based.erc20.cannot.prepare.deploy-tx";
    SdkErrorCode["EVM_ERC20_CANNOT_PREPARE_MINT_TX"] = "evm-based.erc20.cannot.prepare.mint-tx";
    SdkErrorCode["EVM_ERC20_CANNOT_PREPARE_TRANSFER_TX"] = "evm-based.erc20.cannot.prepare.transfer-tx";
    SdkErrorCode["EVM_ERC20_CANNOT_PREPARE_BURN_TX"] = "evm-based.erc20.cannot.prepare.burn-tx";
    SdkErrorCode["EVM_ERC20_CANNOT_PREPARE_APPROVE_TX"] = "evm-based.erc20.cannot.prepare.approve-tx";
    // ERC721
    SdkErrorCode["EVM_ERC721_CANNOT_PREPARE_DEPLOY_TX"] = "evm-based.erc721.cannot.prepare.deploy-tx";
    SdkErrorCode["EVM_ERC721_CANNOT_PREPARE_MINT_TX"] = "evm-based.erc721.cannot.prepare.mint-tx";
    SdkErrorCode["EVM_ERC721_CANNOT_PREPARE_MINT_CASHBACK_TX"] = "evm-based.erc721.cannot.prepare.mint-cashback-tx";
    SdkErrorCode["EVM_ERC721_CANNOT_PREPARE_MINT_MULTIPLE_CASHBACK_TX"] = "evm-based.erc721.cannot.prepare.mint-multiple-cashback-tx";
    SdkErrorCode["EVM_ERC721_CANNOT_PREPARE_MINT_MULTIPLE_TX"] = "evm-based.erc721.cannot.prepare.mint-multiple-tx";
    SdkErrorCode["EVM_ERC721_CANNOT_PREPARE_MINT_PROVENANCE_TX"] = "evm-based.erc721.cannot.prepare.mint-provenance-tx";
    SdkErrorCode["EVM_ERC721_CANNOT_PREPARE_MINT_MULTIPLE_PROVENANCE_TX"] = "evm-based.erc721.cannot.prepare.mint-multiple-provenance-tx";
    SdkErrorCode["EVM_ERC721_CANNOT_PREPARE_ADD_MINTER"] = "evm-based.erc721.cannot.prepare.add-minter";
    SdkErrorCode["EVM_ERC721_CANNOT_PREPARE_BURN_TX"] = "evm-based.erc721.cannot.prepare.burn-tx";
    SdkErrorCode["EVM_ERC721_CANNOT_PREPARE_TRANSFER_TX"] = "evm-based.erc721.cannot.prepare.transfer-tx";
    SdkErrorCode["EVM_ERC721_CANNOT_PREPARE_UPDATE_CASHBACK_TX"] = "evm-based.erc721.cannot.prepare.update-cashback-tx";
    SdkErrorCode["EVM_ERC721_CANNOT_PREPARE_MINT_ALREADY_MINTED"] = "evm-based.erc721.cannot.prepare.mint-minted";
    // ERC1155
    SdkErrorCode["EVM_ERC1155_CANNOT_PREPARE_DEPLOY_TX"] = "evm-based.erc1155.cannot.prepare.deploy-tx";
    SdkErrorCode["EVM_ERC1155_CANNOT_PREPARE_MINT_TX"] = "evm-based.erc1155.cannot.prepare.mint-tx";
    SdkErrorCode["EVM_ERC1155_CANNOT_PREPARE_MINT_BATCH_TX"] = "evm-based.erc1155.cannot.prepare.mint-batch-tx";
    SdkErrorCode["EVM_ERC1155_CANNOT_PREPARE_TRANSFER_TX"] = "evm-based.erc1155.cannot.prepare.transfer-tx";
    SdkErrorCode["EVM_ERC1155_CANNOT_PREPARE_TRANSFER_BATCH_TX"] = "evm-based.erc1155.cannot.prepare.transfer-batch-tx";
    SdkErrorCode["EVM_ERC1155_CANNOT_PREPARE_BURN_TX"] = "evm-based.erc1155.cannot.prepare.burn-tx";
    SdkErrorCode["EVM_ERC1155_CANNOT_PREPARE_BURN_BATCH_TX"] = "evm-based.erc1155.cannot.prepare.burn-batch-tx";
    // Custodial
    SdkErrorCode["EVM_CUSTODIAL_CANNOT_PREPARE_DEPLOY_TX"] = "evm-based.custodial.cannot.prepare.deploy-tx";
    SdkErrorCode["EVM_CUSTODIAL_CANNOT_PREPARE_TRANSFER_TX"] = "evm-based.custodial.cannot.prepare.transfer-tx";
    SdkErrorCode["EVM_CUSTODIAL_CANNOT_PREPARE_TRANSFER_BATCH_TX"] = "evm-based.custodial.cannot.prepare.transfer-batch-tx";
    SdkErrorCode["EVM_CUSTODIAL_CANNOT_PREPARE_APPROVE_TX"] = "evm-based.custodial.cannot.prepare.approve-tx";
    //Gas Pump
    SdkErrorCode["EVM_GAS_PUMP_CANNOT_PREPARE_DEPLOY_BATCH_TX"] = "evm-based.custodial.cannot.prepare.deploy-batch-tx";
    // Smart Contract
    SdkErrorCode["EVM_SMART_CONTRACT_CANNOT_PREPARE_TX"] = "evm-based.smart-contract.cannot.prepare.tx";
    // KMS errors
    SdkErrorCode["KMS_CHAIN_MISMATCH"] = "kms.chain.mismatch";
    // Validation errors
    SdkErrorCode["INSUFFICIENT_FUNDS"] = "insufficient.funds.on.sender.account";
    SdkErrorCode["EVM_TRANSACTION_ERROR"] = "evm-based.smart-contract.transaction.error";
    SdkErrorCode["PARAMETER_MISMATCH"] = "parameter.mismatch";
})(SdkErrorCode = exports.SdkErrorCode || (exports.SdkErrorCode = {}));
// @TODO pass params?
exports.SdkErrorMessage = new Map([
    // General
    [SdkErrorCode.API_ERROR, `Error during api request`],
    [SdkErrorCode.COMMON_ERROR, `Error during execution`],
    [SdkErrorCode.FEE_TOO_SMALL, `Fee is too small`],
    [SdkErrorCode.VALIDATION_AMOUNT, `Amount has to be positive number`],
    [SdkErrorCode.TX_NOT_FOUND, `TX not found`],
    // BTC
    [SdkErrorCode.BTC_BASED_FEE_TOO_SMALL, `Fee is too small. Please make sure that amount to send < balance`],
    [SdkErrorCode.BTC_BASED_DUST_AMOUNT, `Dust amount in one of the outputs`],
    [
        SdkErrorCode.BTC_BASED_UTXO_NOT_FOUND,
        `UTXO with hash {0} and index {1} not found. Please check that outputs are valid`,
    ],
    [SdkErrorCode.BTC_BASED_NO_INPUTS, `Not found spendable inputs`],
    [SdkErrorCode.BTC_BASED_NOT_ENOUGH_BALANCE, `Not enough coins on addresses to perform this transaction`],
    [SdkErrorCode.BTC_FEE_IS_TOO_LARGE, `Fee is too big, make sure it's not a mistake`],
    [
        SdkErrorCode.BTC_BASED_AMOUNT,
        `Amount {0} is incorrect btc-based amount. Should be positive integer and have 8 decimal numbers max`,
    ],
    [
        SdkErrorCode.ADA_BASED_AMOUNT,
        `Amount {0} is incorrect ADA amount. Should be positive integer and have 6 decimal numbers max`,
    ],
    [SdkErrorCode.BTC_BASED_MISSING_PRIVATE_KEY, `Some of private keys is wrong or missing`],
    // XRP
    [SdkErrorCode.XRP_SECRET_DOES_NOT_MATCH, `Secret not valid or doesn't match address`],
    // XLM
    [SdkErrorCode.SECRET_CHECKSUM, `Secret is not valid. Please check your secret for typos`],
    [SdkErrorCode.VALIDATION_TO_ADDRESS, `To address is wrong`],
    [SdkErrorCode.XLM_NO_SEQUENCE, `Account does not contain sequence. Please check account info`],
    // FLOW
    [SdkErrorCode.FLOW_MISSING_PRIVATE_KEY, `No private key available`],
    [SdkErrorCode.FLOW_MISSING_MNEMONIC, `Mnemonic required`],
    [SdkErrorCode.FLOW_MISSING_NETWORK, `Network [testnet/mainnet] required`],
    // CELO
    [
        SdkErrorCode.CELO_MISSING_CURRENCY,
        `The target (to) address, currency, feeCurrency or the amount cannot be empty`,
    ],
    [SdkErrorCode.CELO_MISSING_CONTRACT_ADDRESS, `Contract address and fee currency should not be empty`],
    // SOLANA
    [
        SdkErrorCode.SOLANA_KMS_COMBINATION,
        'Either signatureId with feePayerSignatureId, or fromPrivateKey with feePayerPrivateKey must be present. Combination is not allowed.',
    ],
    // ALGO
    [SdkErrorCode.ALGO_TOKEN_NAME_TOO_LONG, 'Token name should not be more than 8 characters long'],
    // CARDANO
    [SdkErrorCode.FEE_CHANGE_ADDRESS, 'Fee and change address must be both set or both unset.'],
    // EVM
    [
        SdkErrorCode.EVM_INVALID_ADDRESS_SINGLE,
        `invalid address (argument="address", value="someinvalidaddress", code=INVALID_ARGUMENT, version=address/5.7.0) (argument="to", value="someinvalidaddress", code=INVALID_ARGUMENT, version=abi/5.7.0)`,
    ],
    [
        SdkErrorCode.EVM_INVALID_ADDRESS_ARRAY,
        `invalid address (argument="address", value="someinvalidaddress", code=INVALID_ARGUMENT, version=address/5.7.0) (argument=null, value="someinvalidaddress", code=INVALID_ARGUMENT, version=abi/5.7.0)`,
    ],
    // ERC721
    [SdkErrorCode.EVM_ERC721_CANNOT_PREPARE_MINT_ALREADY_MINTED, `Token with provided tokenId already minted`],
]);
//# sourceMappingURL=errors.abstract.sdk.js.map