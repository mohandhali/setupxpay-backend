"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sleepSeconds = exports.sleep = exports.toHexString = exports.wrapErrorIfNeeded = exports.placeArgsToString = exports.isWithSignatureId = exports.amountUtils = void 0;
const tslib_1 = require("tslib");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const errors_abstract_sdk_1 = require("./errors.abstract.sdk");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
exports.amountUtils = {
    /**
     * Can't be in abstract-blockchain. Bug with bitcore
     * https://github.com/bitpay/bitcore-lib/pull/238
     * https://github.com/bitpay/bitcore-lib/issues/180
     */
    toSatoshis: (amount) => {
        const amountBigNumber = new bignumber_js_1.default(amount);
        const satoshiValue = amountBigNumber.multipliedBy(10 ** 8);
        const satoshis = satoshiValue.integerValue();
        if (satoshis.toFixed() !== satoshiValue.toFixed() || satoshis.lt(0)) {
            throw new errors_abstract_sdk_1.SdkError({ code: errors_abstract_sdk_1.SdkErrorCode.BTC_BASED_AMOUNT, messageArgs: [amountBigNumber.toString()] });
        }
        return Number(satoshis);
    },
    fromSatoshis: (amount) => new bignumber_js_1.default(amount).dividedBy(10 ** 8).toNumber(),
    toLovelace: (amount) => {
        const amountBigNumber = new bignumber_js_1.default(amount);
        const satoshiValue = amountBigNumber.multipliedBy(10 ** 6);
        const satoshis = satoshiValue.integerValue();
        if (satoshis.toFixed() !== satoshiValue.toFixed() || satoshis.lt(0)) {
            throw new errors_abstract_sdk_1.SdkError({ code: errors_abstract_sdk_1.SdkErrorCode.ADA_BASED_AMOUNT, messageArgs: [amountBigNumber.toString()] });
        }
        return Number(satoshis);
    },
    fromLovelace: (amount) => new bignumber_js_1.default(amount).dividedBy(10 ** 6).toNumber(),
    amountToHexString: (amount, decimals) => (0, exports.toHexString)(new bignumber_js_1.default(amount).multipliedBy(10 ** decimals)),
};
function isWithSignatureId(input) {
    return input.signatureId !== undefined;
}
exports.isWithSignatureId = isWithSignatureId;
const placeArgsToString = (message, args) => {
    var _a;
    if (!message) {
        return message;
    }
    if (((_a = args === null || args === void 0 ? void 0 : args.length) !== null && _a !== void 0 ? _a : 0) > 0) {
        let placedMessage = message;
        args === null || args === void 0 ? void 0 : args.forEach((value, index) => {
            placedMessage = placedMessage.replace(`{${index}}`, `${value}`);
        });
        return placedMessage;
    }
    return message;
};
exports.placeArgsToString = placeArgsToString;
const wrapErrorIfNeeded = (e) => {
    if (lodash_1.default.isString(e)) {
        return new Error(e);
    }
    return e;
};
exports.wrapErrorIfNeeded = wrapErrorIfNeeded;
const toHexString = (value) => `0x${value.toString(16)}`;
exports.toHexString = toHexString;
const sleep = (ms) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return new Promise((resolve) => setTimeout(resolve, ms)); });
exports.sleep = sleep;
const sleepSeconds = (sec) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return new Promise((resolve) => setTimeout(resolve, sec * 1000)); });
exports.sleepSeconds = sleepSeconds;
//# sourceMappingURL=utils.js.map