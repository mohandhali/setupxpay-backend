"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.abstractSdkLedgerService = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@tatumio/api-client");
const abstractSdkLedgerService = () => {
    return {
        customer: {
            get: api_client_1.CustomerService.getCustomerByExternalOrInternalId,
            getAll: api_client_1.CustomerService.findAllCustomers,
            update: api_client_1.CustomerService.updateCustomer,
            activate: api_client_1.CustomerService.activateCustomer,
            deactivate: api_client_1.CustomerService.deactivateCustomer,
            enable: api_client_1.CustomerService.enableCustomer,
            disable: api_client_1.CustomerService.disableCustomer,
        },
        orderBook: {
            getHistorical: api_client_1.OrderBookService.getHistoricalTradesBody,
            getActiveBuyTrades: api_client_1.OrderBookService.getBuyTradesBody,
            getActiveSellTrades: api_client_1.OrderBookService.getSellTradesBody,
            newTrade: api_client_1.OrderBookService.storeTrade,
            get: api_client_1.OrderBookService.getTradeById,
            cancel: api_client_1.OrderBookService.deleteTrade,
            cancelByAccount: api_client_1.OrderBookService.deleteAccountTrades,
        },
        transaction: {
            send: api_client_1.TransactionService.sendTransaction,
            sendMultiple: api_client_1.TransactionService.sendTransactionBatch,
            getAll: api_client_1.TransactionService.getTransactions,
            getAllByAccount: api_client_1.TransactionService.getTransactionsByAccountId,
            getAllByCustomer: api_client_1.TransactionService.getTransactionsByCustomerId,
            getAllByReference: api_client_1.TransactionService.getTransactionsByReference,
            countByAccount: function (filter) {
                return api_client_1.TransactionService.getTransactionsByAccountId(filter, 50, 0, true);
            },
            countByCustomer: function (filter) {
                return api_client_1.TransactionService.getTransactionsByCustomerId(filter, 50, 0, true);
            },
            // @TODO OPENAPI
            /*countByReference: function (reference: string) {
              return this.getAllByReference(reference, 50, 0, true)
            },*/
        },
        virtualCurrency: {
            create: api_client_1.VirtualCurrencyService.createCurrency,
            mint: api_client_1.VirtualCurrencyService.mintCurrency,
            revoke: api_client_1.VirtualCurrencyService.revokeCurrency,
            getByName: api_client_1.VirtualCurrencyService.getCurrency,
            update: api_client_1.VirtualCurrencyService.updateCurrency,
        },
        blockAmount: {
            block: api_client_1.AccountService.blockAmount,
            unblock: api_client_1.AccountService.deleteBlockAmount,
            unblockWithTransaction: api_client_1.AccountService.unblockAmountWithTransaction,
        },
        account: {
            get: api_client_1.AccountService.getAccountByAccountId,
            getAll: api_client_1.AccountService.getAccounts,
            getByCustomerId: api_client_1.AccountService.getAccountsByCustomerId,
            getBalance: api_client_1.AccountService.getAccountBalance,
            create: api_client_1.AccountService.createAccount,
            createMultiple: api_client_1.AccountService.createAccountBatch,
            update: api_client_1.AccountService.updateAccountByAccountId,
            getBlockedAmountsByAccountId: api_client_1.AccountService.getBlockAmountById,
            activate: api_client_1.AccountService.activateAccount,
            deactivate: api_client_1.AccountService.deactivateAccount,
            freeze: api_client_1.AccountService.freezeAccount,
            unfreeze: api_client_1.AccountService.unfreezeAccount,
            /**
             * Abstraction unification endpoint for creating new ledger account, optionally added wallet generation, generating deposit blockchain address
             * and register incoming TX webhook notification.
             * @param account Account to be created.
             * @param generateNewWalletFn Function for creation of the new wallet. If you don't want to create a new wallet, pass undefined
             * @param generateNewWallet Function for creation of the new wallet. If you don't want to create a new wallet, pass undefined
             * @param testnet if we are using testnet or not
             * @param webhookUrl optional URL, where webhook will be post for every incoming blockchain transaction to the address
             */
            generate: (account, generateNewWalletFn, generateNewWallet = true, testnet = true, webhookUrl) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                let w;
                if (generateNewWallet) {
                    w = yield generateNewWalletFn(undefined, { testnet });
                    account.xpub = w.xpub; // || w.address @TODO not in wallet type
                }
                const a = yield api_client_1.AccountService.createAccount(account);
                const address = yield api_client_1.ApiServices.virtualAccount.account.generateDepositAddress(a.id);
                if (webhookUrl) {
                    yield api_client_1.ApiServices.ledger.subscriptions.createSubscription({
                        type: 'ACCOUNT_INCOMING_BLOCKCHAIN_TRANSACTION',
                        attr: { url: webhookUrl, id: a.id },
                    });
                }
                return { account: a, address, wallet: w };
            }),
        },
    };
};
exports.abstractSdkLedgerService = abstractSdkLedgerService;
//# sourceMappingURL=ledger.abstract.js.map