"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.abstractSdkNftService = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@tatumio/api-client");
const shared_core_1 = require("@tatumio/shared-core");
const abstractSdkNftService = () => {
    return {
        deployNFTSmartContract: api_client_1.NftErc721OrCompatibleService.nftDeployErc721,
        addNFTMinter: api_client_1.NftErc721OrCompatibleService.nftAddMinter,
        mintNFT: api_client_1.NftErc721OrCompatibleService.nftMintErc721,
        mintMultipleNFTs: api_client_1.NftErc721OrCompatibleService.nftMintMultipleErc721,
        burnNFT: api_client_1.NftErc721OrCompatibleService.nftBurnErc721,
        transferNFT: api_client_1.NftErc721OrCompatibleService.nftTransferErc721,
        getNFTTransaction: api_client_1.NftErc721OrCompatibleService.nftGetTransactErc721,
        getNFTTransactionsByToken: api_client_1.NftErc721OrCompatibleService.nftGetTransactionByToken,
        getNFTTransactionsByAddress: api_client_1.NftErc721OrCompatibleService.nftGetTransactionByAddress,
        getNFTsByAddress: api_client_1.NftErc721OrCompatibleService.nftGetTokensByAddressErc721,
        getNFTMetadataURI: api_client_1.NftErc721OrCompatibleService.nftGetMetadataErc721,
        getNFTAccountBalance: api_client_1.NftErc721OrCompatibleService.nftGetBalanceErc721,
        getNFTContractAddress: api_client_1.NftErc721OrCompatibleService.nftGetContractAddress,
        getNFTImage: (chain, contractAddress, tokenId, account) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            var _a;
            const response = yield api_client_1.NftErc721OrCompatibleService.nftGetMetadataErc721(chain, contractAddress, tokenId, account);
            let metadata;
            if (chain === 'SOL') {
                metadata = (_a = response === null || response === void 0 ? void 0 : response.onchainData) === null || _a === void 0 ? void 0 : _a.uri;
            }
            else {
                metadata = response === null || response === void 0 ? void 0 : response.data;
            }
            if (!metadata)
                return null;
            const metadataUrl = `https://gateway.pinata.cloud/ipfs/${metadata === null || metadata === void 0 ? void 0 : metadata.replace('ipfs://', '')}`;
            const { data } = yield shared_core_1.httpHelper.get(metadataUrl);
            const imageUrl = data.image;
            return {
                originalUrl: imageUrl,
                publicUrl: `https://gateway.pinata.cloud/ipfs/${imageUrl.replace('ipfs://', '')}`,
            };
        }),
        prepareAddNftMinterAbstraction: (body) => {
            return ['0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6', body.minter];
        },
    };
};
exports.abstractSdkNftService = abstractSdkNftService;
//# sourceMappingURL=nft.abstract.js.map