"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressTransformerDefault = exports.evmBasedUtils = void 0;
const tslib_1 = require("tslib");
const ethereumjs_wallet_1 = tslib_1.__importStar(require("ethereumjs-wallet"));
const shared_core_1 = require("@tatumio/shared-core");
const bip39_1 = require("bip39");
const web3_utils_1 = require("web3-utils");
const shared_abstract_sdk_1 = require("@tatumio/shared-abstract-sdk");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const contracts_1 = require("./contracts");
const evm_based_sdk_errors_1 = require("./evm-based.sdk.errors");
exports.evmBasedUtils = {
    generateAddressFromXPub: (xpub, i, prefix = shared_core_1.ADDRESS_PREFIX.EVM) => {
        const w = ethereumjs_wallet_1.hdkey.fromExtendedKey(xpub);
        const wallet = w.deriveChild(i).getWallet();
        return prefix + wallet.getAddress().toString('hex').toLowerCase();
    },
    generatePrivateKeyFromMnemonic: (blockchain, mnemonic, i, options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const derivationPath = (0, shared_core_1.getDerivationPath)(blockchain, options);
        const hdwallet = ethereumjs_wallet_1.hdkey.fromMasterSeed(yield (0, bip39_1.mnemonicToSeed)(mnemonic));
        const derivePath = hdwallet.derivePath(derivationPath).deriveChild(i);
        return derivePath.getWallet().getPrivateKeyString();
    }),
    generateAddressFromPrivateKey: (blockchain, privateKey, prefix = shared_core_1.ADDRESS_PREFIX.EVM) => {
        const wallet = ethereumjs_wallet_1.default.fromPrivateKey(Buffer.from(privateKey.replace(prefix, ''), 'hex'));
        return wallet.getAddressString();
    },
    generateBlockchainWallet: (blockchain, mnemonic, options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const mnem = mnemonic !== null && mnemonic !== void 0 ? mnemonic : (0, bip39_1.generateMnemonic)(256);
        const derivationPath = (0, shared_core_1.getDerivationPath)(blockchain, options);
        const hdwallet = ethereumjs_wallet_1.hdkey.fromMasterSeed(yield (0, bip39_1.mnemonicToSeed)(mnem));
        const derivePath = hdwallet.derivePath(derivationPath);
        return {
            xpub: derivePath.publicExtendedKey().toString(),
            mnemonic: mnem,
        };
    }),
    prepareSignedTransactionAbstraction: (client, transaction, web3, signatureId, fromPrivateKey, gasLimit, gasPrice, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const gasPriceDefined = gasPrice
            ? client.utils.toWei(gasPrice, 'gwei')
            : yield web3.getGasPriceInWei(provider);
        const tx = Object.assign(Object.assign({ from: 0 }, transaction), { gas: gasLimit, gasPrice: gasPriceDefined });
        if (signatureId) {
            return JSON.stringify(tx);
        }
        tx.from = tx.from || client.eth.defaultAccount || 0;
        tx.gas = (_a = tx.gas) !== null && _a !== void 0 ? _a : (yield exports.evmBasedUtils.estimateGasLimit({ client, tx, fromPrivateKey }));
        if (!fromPrivateKey) {
            throw new Error('signatureId or fromPrivateKey has to be defined');
        }
        yield exports.evmBasedUtils.validateSenderBalance(client, fromPrivateKey, tx);
        const signedTransaction = yield client.eth.accounts.signTransaction(tx, fromPrivateKey);
        if (!signedTransaction.rawTransaction) {
            throw new Error('Unable to get signed tx data');
        }
        return signedTransaction.rawTransaction;
    }),
    estimateGasLimit: ({ client, tx, fromPrivateKey, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        try {
            return yield client.eth.estimateGas(tx);
        }
        catch (e) {
            if (e instanceof Error &&
                e.message.includes(evm_based_sdk_errors_1.EvmBasedErrorCodesFromNode.GAS_REQUIRED_EXCEEDS_ALLOWANCE.substring)) {
                if (fromPrivateKey) {
                    const { address } = client.eth.accounts.privateKeyToAccount(fromPrivateKey);
                    throw evm_based_sdk_errors_1.EvmBasedErrorCodesFromNode.GAS_REQUIRED_EXCEEDS_ALLOWANCE.error({ e, address });
                }
                throw evm_based_sdk_errors_1.EvmBasedErrorCodesFromNode.GAS_REQUIRED_EXCEEDS_ALLOWANCE.error({ e });
            }
            throw e;
        }
    }),
    validateErc20Balance: (client, privateKey, contractAddress, amount) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const account = client.eth.accounts.privateKeyToAccount(privateKey);
        const contract = new client.eth.Contract(contracts_1.Erc20Token.abi, contractAddress);
        const balance = yield contract.methods.balanceOf(account.address).call();
        const decimals = yield contract.methods.decimals().call();
        if (!balance || new bignumber_js_1.default(balance).dividedBy(new bignumber_js_1.default(10).pow(decimals)).isLessThan(amount)) {
            throw new evm_based_sdk_errors_1.EvmBasedSdkError({
                code: shared_abstract_sdk_1.SdkErrorCode.INSUFFICIENT_FUNDS,
                error: new Error(`Insufficient funds erc20 transaction from account ${account.address} -> available balance is ${new bignumber_js_1.default(balance)
                    .dividedBy(new bignumber_js_1.default(10).pow(decimals))
                    .toString()}, required balance is ${amount}`),
            });
        }
    }),
    validateSenderBalance: (client, privateKey, tx) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const { gas, gasPrice, nonce } = tx, txWithoutGas = tslib_1.__rest(tx, ["gas", "gasPrice", "nonce"]);
        let estimate;
        try {
            estimate = new bignumber_js_1.default(yield client.eth.estimateGas(txWithoutGas));
        }
        catch (e) {
            if (!gas) {
                throw new evm_based_sdk_errors_1.EvmBasedSdkError({
                    code: shared_abstract_sdk_1.SdkErrorCode.EVM_TRANSACTION_ERROR,
                    error: new Error(`Unable to estimate gas. transaction ${tx}, returned with error ${e}`),
                });
            }
            estimate = new bignumber_js_1.default(gas);
        }
        let threshold = estimate.multipliedBy(new bignumber_js_1.default(tx.gasPrice));
        if (tx.value) {
            threshold = threshold.plus(tx.value);
        }
        const account = client.eth.accounts.privateKeyToAccount(privateKey);
        const balance = yield client.eth.getBalance(account.address);
        if (!balance || new bignumber_js_1.default(balance).isLessThan(threshold)) {
            throw new evm_based_sdk_errors_1.EvmBasedSdkError({
                code: shared_abstract_sdk_1.SdkErrorCode.INSUFFICIENT_FUNDS,
                error: new Error(`Insufficient funds send transaction from account ${account.address} -> available balance is ${balance}, required balance is ${threshold}`),
            });
        }
    }),
    transformToWei: (amount, unit = 'ether') => {
        return (0, web3_utils_1.toWei)(amount, unit);
    },
    amountToWeiHex: (amount, unit = 'ether') => (0, web3_utils_1.toHex)(exports.evmBasedUtils.transformToWei(amount, unit)),
    decimals: (contractAddress, web3, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const client = web3.getClient(provider);
        return new client.eth.Contract(contracts_1.Erc20Token.abi, contractAddress).methods.decimals().call();
    }),
    gasLimitToHexWithFallback: (gasLimit, fallback) => gasLimit ? (0, shared_abstract_sdk_1.toHexString)(new bignumber_js_1.default(gasLimit)) : fallback,
    gasPriceWeiToHexWithFallback: (gasPrice, fallback) => gasPrice ? (0, shared_abstract_sdk_1.toHexString)(new bignumber_js_1.default((0, web3_utils_1.toWei)(gasPrice, 'gwei'))) : fallback,
    storeDataTransaction: (body, web3, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const client = web3.getClient(provider, body.fromPrivateKey);
        const hexData = (0, web3_utils_1.isHex)(body.data) ? (0, web3_utils_1.stringToHex)(body.data) : (0, web3_utils_1.toHex)(body.data);
        const tx = {
            from: 0,
            to: body.to || client.eth.accounts.wallet[0].address,
            data: hexData,
            gas: body.gasLimit,
            nonce: body.nonce,
            gasPrice: body.gasPrice
                ? `0x${new bignumber_js_1.default((0, web3_utils_1.toWei)(body.gasPrice, 'gwei')).toString(16)}`
                : yield web3.getGasPriceInWei(provider),
        };
        return exports.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, body.signatureId, body.fromPrivateKey, body.gasLimit, body.gasPrice, provider);
    }),
    tryCatch: (method, code) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        try {
            return yield method();
        }
        catch (e) {
            if (e instanceof shared_abstract_sdk_1.SdkError) {
                throw e;
            }
            throw new evm_based_sdk_errors_1.EvmBasedSdkError({ error: e, code });
        }
    }),
    alreadyMinted: (contract, tokenId) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        try {
            yield contract.methods.ownerOf(tokenId).call();
            return true;
        }
        catch (e) {
            return false;
        }
    }),
};
const AddressTransformerDefault = (address) => address;
exports.AddressTransformerDefault = AddressTransformerDefault;
//# sourceMappingURL=evm-based.utils.js.map