"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.evmBasedAuction = exports.AUCTION_BLOCKCHAINS_CONSTANTS = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@tatumio/api-client");
const shared_core_1 = require("@tatumio/shared-core");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const contracts_1 = require("../contracts");
const web3_utils_1 = require("web3-utils");
const evm_based_utils_1 = require("../evm-based.utils");
exports.AUCTION_BLOCKCHAINS_CONSTANTS = Object.assign(Object.assign({}, shared_core_1.Blockchain), { HARMONY: 'ONE', POLYGON: 'MATIC' });
const evmBasedAuction = (args) => {
    const { blockchain, web3, broadcastFunction } = args;
    return {
        /**
         * For more details, see <a href="https://tatum.io/apidoc#operation/MPAuction" target="_blank">Tatum API documentation</a>
         */
        getAuction: (contractAddress, auctionId) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            return api_client_1.AuctionService.getAuction(exports.AUCTION_BLOCKCHAINS_CONSTANTS[blockchain], contractAddress, auctionId);
        }),
        /**
         * For more details, see <a href="https://tatum.io/apidoc#operation/MPAuctionFee" target="_blank">Tatum API documentation</a>
         */
        getAuctionFee: (contractAddress) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            return api_client_1.AuctionService.getAuctionFee(exports.AUCTION_BLOCKCHAINS_CONSTANTS[blockchain], contractAddress);
        }),
        /**
         * For more details, see <a href="https://tatum.io/apidoc#operation/MPAuctionRecipient" target="_blank">Tatum API documentation</a>
         */
        getAuctionFeeRecipient: (contractAddress) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            return api_client_1.AuctionService.getAuctionFeeRecipient(exports.AUCTION_BLOCKCHAINS_CONSTANTS[blockchain], contractAddress);
        }),
        prepare: {
            /**
             * Sign ETH deploy NFT Auction contract transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the ETH Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain, or signatureId in case of Tatum KMS
             */
            deployAuctionSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return deployAuctionSignedTransaction(body, web3, provider); }),
            auctionUpdateFeeRecipientSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return auctionUpdateFeeRecipientSignedTransaction(body, web3, provider); }),
            /**
             * Create new auction on the auction contract. Before auction, seller must approve spending of the NFT token for the Auction contract.
             * After auction is created, auction contract transfers the asset to the auction smart contract.
             * Only auction for existing NFTs can be created - seller must be owner of the NFT asset.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns transaction data to be broadcast to blockchain, or signatureId in case of Tatum KMS
             */
            createAuctionSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return createAuctionSignedTransaction(body, web3, provider); }),
            /**
             * Approve NFT transfer for auction to perform listing of the asset.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns transaction data to be broadcast to blockchain, or signatureId in case of Tatum KMS
             */
            auctionApproveNftTransferSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return auctionApproveNftTransferSignedTransaction(body, web3, provider); }),
            /**
             * Approve ERC20 transfer for auction to perform bidding on the asset in the auction.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns transaction data to be broadcast to blockchain, or signatureId in case of Tatum KMS
             */
            auctionApproveErc20TransferSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return auctionApproveErc20TransferSignedTransaction(body, web3, provider); }),
            /**
             * Bid on the auction. Buyer must either send native assets with this operation, or approve ERC20 token spending before.
             * After auction is sold, it's in a pending state to be processed by the auction. Noone receives the assets unless the auction operator processes that.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns transaction data to be broadcast to blockchain, or signatureId in case of Tatum KMS
             */
            auctionBidSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return auctionBidSignedTransaction(body, blockchain, broadcastFunction, web3, provider); }),
            /**
             * Cancel auction on the auction. Only possible for the seller or the operator. There must be no buyer present for that auction. NFT asset is sent back to the seller.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns transaction data to be broadcast to blockchain, or signatureId in case of Tatum KMS
             */
            auctionCancelSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return auctionCancelSignedTransaction(body, web3, provider); }),
            /**
             * Settle auction. There must be buyer present for that auction. NFT will be sent to the bidder, assets to the seller and fee to the operator.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            auctionSettleSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return auctionSettleSignedTransaction(body, web3, provider); }),
        },
        send: {
            /**
             * Deploy new smart contract for NFT auction logic. Smart contract enables auction operator to create new auction for NFT (ERC-721/1155).
             * Operator can set a fee in percentage, which will be paid on top of the price of the asset.
             * can be offered for native asset - ETH, BSC, etc. - or any ERC20 token - this is configurable during auction creation.
             * Before auction is created, seller must approve transfer of the NFT to the auction contract.
             * Buyer will bid for the asset from the auction using native asset - send assets along the gid() smart contract call, or via ERC20 token.
             * Buyer of the auction must perform approval for the smart contract to access ERC20 token, before the actual bid() method is called.
             * Once there is higher bid than the actual one, the previous bidder's funds will be returned to him and new bidder will be the current winning one.
             * When auction ends, anyone can settle the auction - NFT will be sent to the bidder, assets to the seller and fee to the operator.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            deployAuctionSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.AuctionService.generateAuction(body);
                }
                else
                    return broadcastFunction({
                        txData: yield deployAuctionSignedTransaction(body, web3, provider),
                    });
            }),
            /**
             * Update auction fee recipient.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            auctionUpdateFeeRecipientSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.AuctionService.updateAuctionFeeRecipient(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield auctionUpdateFeeRecipientSignedTransaction(body, web3, provider),
                    });
                }
            }),
            /**
             * Create new auction on the auction contract. Before auction, seller must approve spending of the NFT token for the Auction contract.
             * After auction is created, auction contract transfers the asset to the auction smart contract.
             * Only auction for existing NFTs can be created - seller must be owner of the NFT asset.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            createAuctionSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.AuctionService.createAuction(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield createAuctionSignedTransaction(body, web3, provider),
                    });
                }
            }),
            /**
             * Approve NFT transfer for auction to perform listing of the asset.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            auctionApproveNftTransferSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.AuctionService.approveNftAuctionSpending(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield auctionApproveNftTransferSignedTransaction(body, web3, provider),
                    });
                }
            }),
            /**
             * Approve ERC20 transfer for auction to perform bidding on the asset in the auction.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            auctionApproveErc20TransferSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.FungibleTokensErc20OrCompatibleService.erc20Approve(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield auctionApproveErc20TransferSignedTransaction(body, web3, provider),
                    });
                }
            }),
            auctionBidSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.AuctionService.bidOnAuction(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield auctionBidSignedTransaction(body, blockchain, broadcastFunction, web3, provider),
                    });
                }
            }),
            /**
             * Cancel auction on the auction. Only possible for the seller or the operator. There must be no buyer present for that auction. NFT asset is sent back to the seller.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            auctionCancelSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.AuctionService.cancelAuction(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield auctionCancelSignedTransaction(body, web3, provider),
                    });
                }
            }),
            auctionSettleSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.AuctionService.settleAuction(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield auctionSettleSignedTransaction(body, web3, provider),
                    });
                }
            }),
        },
    };
};
exports.evmBasedAuction = evmBasedAuction;
const deployAuctionSignedTransaction = (body, web3, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const client = web3.getClient(provider, body === null || body === void 0 ? void 0 : body.fromPrivateKey);
    // TODO any type
    const contract = new client.eth.Contract(contracts_1.MarketplaceSmartContract.abi);
    const deploy = contract.deploy({
        arguments: [body.auctionFee, body.feeRecipient],
        data: contracts_1.MarketplaceSmartContract.bytecode,
    });
    const tx = {
        from: 0,
        data: deploy.encodeABI(),
        nonce: body.nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, body.signatureId, body.fromPrivateKey, (_a = body.fee) === null || _a === void 0 ? void 0 : _a.gasLimit, (_b = body.fee) === null || _b === void 0 ? void 0 : _b.gasPrice);
});
const auctionUpdateFeeRecipientSignedTransaction = (body, web3, provider) => {
    var _a, _b;
    const client = web3.getClient(provider, body === null || body === void 0 ? void 0 : body.fromPrivateKey);
    const methodName = 'setAuctionFeeRecipient';
    const methodAbi = contracts_1.MarketplaceSmartContract.abi.find((a) => a.name === methodName);
    // TODO any type
    const contract = new client.eth.Contract([methodAbi]);
    const params = [body.feeRecipient];
    const tx = {
        from: 0,
        to: body.contractAddress.trim(),
        value: body.amount
            ? `0x${new bignumber_js_1.default(client.utils.toWei(body.amount, 'ether')).toString(16)}`
            : undefined,
        data: contract.methods[methodName](...params).encodeABI(),
        nonce: body.nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, body.signatureId, body.fromPrivateKey, (_a = body.fee) === null || _a === void 0 ? void 0 : _a.gasLimit, (_b = body.fee) === null || _b === void 0 ? void 0 : _b.gasPrice);
};
const auctionApproveNftTransferSignedTransaction = (body, web3, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _c, _d;
    const client = web3.getClient(provider, body === null || body === void 0 ? void 0 : body.fromPrivateKey);
    const methodName = body.isErc721 ? 'approve' : 'setApprovalForAll';
    const abi = body.isErc721 ? contracts_1.Erc721Token_Cashback.abi : contracts_1.Erc1155.abi;
    const methodAbi = abi.find((a) => a.name === methodName);
    // TODO any type
    const contract = new client.eth.Contract([methodAbi]);
    const params = body.isErc721
        ? [body.spender, `0x${new bignumber_js_1.default(body.tokenId).toString(16)}`]
        : [body.spender, true];
    const data = contract.methods[methodName](...params).encodeABI();
    const tx = {
        from: 0,
        to: body.contractAddress.trim(),
        data,
        nonce: body.nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, body.signatureId, body.fromPrivateKey, (_c = body.fee) === null || _c === void 0 ? void 0 : _c.gasLimit, (_d = body.fee) === null || _d === void 0 ? void 0 : _d.gasPrice);
});
const auctionApproveErc20TransferSignedTransaction = (body, web3, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _e, _f;
    const client = web3.getClient(provider, body === null || body === void 0 ? void 0 : body.fromPrivateKey);
    const amount = new bignumber_js_1.default(body.amount)
        .multipliedBy(new bignumber_js_1.default(10).pow(
    // TODO any type
    yield new client.eth.Contract(contracts_1.Erc20Token.abi, body.contractAddress.trim()).methods
        .decimals()
        .call()))
        .toString(16);
    const params = [body.spender.trim(), `0x${amount}`];
    body.amount = '0';
    const methodName = 'approve';
    const methodAbi = contracts_1.Erc20Token.abi.find((a) => a.name === methodName);
    const contract = new client.eth.Contract([methodAbi]);
    const tx = {
        from: 0,
        to: body.contractAddress.trim(),
        value: amount ? `0x${new bignumber_js_1.default((0, web3_utils_1.toWei)(body.amount, 'ether')).toString(16)}` : undefined,
        data: contract.methods[methodName](...params).encodeABI(),
        nonce: body.nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, body.signatureId, body.fromPrivateKey, (_e = body.fee) === null || _e === void 0 ? void 0 : _e.gasLimit, (_f = body.fee) === null || _f === void 0 ? void 0 : _f.gasPrice);
});
const auctionBidSignedTransaction = (body, blockchain, broadcastFunction, web3, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _g, _h;
    const client = web3.getClient(provider, body === null || body === void 0 ? void 0 : body.fromPrivateKey);
    const a = yield new client.eth.Contract(contracts_1.MarketplaceSmartContract.abi, body.contractAddress).methods
        .getAuction(body.id)
        .call();
    let decimals = 18;
    let methodName = 'bid';
    let amount = undefined;
    if (a[6] !== '0x0000000000000000000000000000000000000000') {
        decimals = yield evm_based_utils_1.evmBasedUtils.decimals(a[6], web3, provider);
        if (body.bidder) {
            methodName = 'bidForExternalBidder';
        }
    }
    else if (body.bidder) {
        throw new Error('Bidder could be present only for ERC20 based auctions.');
    }
    else {
        amount = body.bidValue;
    }
    if (!body.bidValue) {
        throw new Error('No budValue set');
    }
    const params = [
        body.id,
        `0x${new bignumber_js_1.default(body.bidValue).multipliedBy(new bignumber_js_1.default(10).pow(decimals)).toString(16)}`,
    ];
    if (body.bidder) {
        params.push(body.bidder.trim());
    }
    const methodAbi = contracts_1.MarketplaceSmartContract.abi.find((a) => a.name === methodName);
    // TODO any type
    const contract = new client.eth.Contract([methodAbi]);
    const tx = {
        from: 0,
        to: body.contractAddress.trim(),
        value: amount ? `0x${new bignumber_js_1.default(client.utils.toWei(amount, 'ether')).toString(16)}` : undefined,
        data: contract.methods[methodName](...params).encodeABI(),
        nonce: body.nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, body.signatureId, body.fromPrivateKey, (_g = body.fee) === null || _g === void 0 ? void 0 : _g.gasLimit, (_h = body.fee) === null || _h === void 0 ? void 0 : _h.gasPrice);
});
const auctionCancelSignedTransaction = (body, web3, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _j, _k;
    const client = web3.getClient(provider, body === null || body === void 0 ? void 0 : body.fromPrivateKey);
    const methodName = 'cancelAuction';
    const methodAbi = contracts_1.MarketplaceSmartContract.abi.find((a) => a.name === methodName);
    const params = [body.id];
    // TODO any type
    const contract = new client.eth.Contract([methodAbi]);
    const tx = {
        from: 0,
        to: body.contractAddress.trim(),
        value: body.amount
            ? `0x${new bignumber_js_1.default(client.utils.toWei(body.amount, 'ether')).toString(16)}`
            : undefined,
        data: contract.methods[methodName](...params).encodeABI(),
        nonce: body.nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, body.signatureId, body.fromPrivateKey, (_j = body.fee) === null || _j === void 0 ? void 0 : _j.gasLimit, (_k = body.fee) === null || _k === void 0 ? void 0 : _k.gasPrice);
});
const auctionSettleSignedTransaction = (body, web3, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _l, _m;
    const client = web3.getClient(provider, body === null || body === void 0 ? void 0 : body.fromPrivateKey);
    const params = [body.id];
    const methodName = 'settleAuction';
    const methodAbi = contracts_1.MarketplaceSmartContract.abi.find((a) => a.name === methodName);
    // TODO any type
    const contract = new client.eth.Contract([methodAbi]);
    const tx = {
        from: 0,
        to: body.contractAddress.trim(),
        value: body.amount
            ? `0x${new bignumber_js_1.default(client.utils.toWei(body.amount, 'ether')).toString(16)}`
            : undefined,
        data: contract.methods[methodName](...params).encodeABI(),
        nonce: body.nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, body.signatureId, body.fromPrivateKey, (_l = body.fee) === null || _l === void 0 ? void 0 : _l.gasLimit, (_m = body.fee) === null || _m === void 0 ? void 0 : _m.gasPrice);
});
const createAuctionSignedTransaction = (body, web3, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _o, _p;
    const client = web3.getClient(provider, body === null || body === void 0 ? void 0 : body.fromPrivateKey);
    const params = [
        body.id,
        body.isErc721,
        body.nftAddress.trim(),
        `0x${new bignumber_js_1.default(body.tokenId).toString(16)}`,
        body.seller.trim(),
        `0x${new bignumber_js_1.default(body.amount || 0).toString(16)}`,
        `0x${new bignumber_js_1.default(body.endedAt).toString(16)}`,
        body.erc20Address || '0x0000000000000000000000000000000000000000',
    ];
    body.amount = undefined;
    const methodName = 'createAuction';
    const methodAbi = contracts_1.MarketplaceSmartContract.abi.find((a) => a.name === methodName);
    // TODO any type
    const contract = new client.eth.Contract([methodAbi]);
    const tx = {
        from: 0,
        to: body.contractAddress.trim(),
        data: contract.methods[methodName](...params).encodeABI(),
        nonce: body.nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, body.signatureId, body.fromPrivateKey, (_o = body.fee) === null || _o === void 0 ? void 0 : _o.gasLimit, (_p = body.fee) === null || _p === void 0 ? void 0 : _p.gasPrice);
});
//# sourceMappingURL=evm-based.auction.js.map