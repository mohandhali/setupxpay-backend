import { ApproveCeloErc20, ApproveErc20, ApproveNftSpending, ApproveNftSpendingCelo, BidOnAuction, BidOnAuctionCelo, CancelAuction, CancelAuctionCelo, CreateAuction, CreateAuctionCelo, GenerateAuction, GenerateAuctionCelo, UpdateFeeRecipient, UpdateFeeRecipientCelo } from '@tatumio/api-client';
import { Blockchain, EvmBasedBlockchain } from '@tatumio/shared-core';
import { BroadcastFunction, FromPrivateKeyOrSignatureId } from '@tatumio/shared-blockchain-abstract';
import { EvmBasedWeb3 } from './evm-based.web3';
export declare type AuctionBlockchainNames = 'ETH' | 'ONE' | 'CELO' | 'MATIC' | 'BSC';
export declare const AUCTION_BLOCKCHAINS_CONSTANTS: Record<Blockchain, string>;
export declare const evmBasedAuction: (args: {
    blockchain: EvmBasedBlockchain;
    web3: EvmBasedWeb3;
    broadcastFunction: BroadcastFunction;
}) => {
    /**
     * For more details, see <a href="https://tatum.io/apidoc#operation/MPAuction" target="_blank">Tatum API documentation</a>
     */
    getAuction: (contractAddress: string, auctionId: string) => Promise<{
        amount?: string;
        bidder?: string;
        erc20Address?: string;
        isErc721?: boolean;
        startedAt?: string;
        endedAt?: string;
        nftAddress?: string;
        endingPrice?: string;
        seller?: string;
        highestBid?: string;
    }>;
    /**
     * For more details, see <a href="https://tatum.io/apidoc#operation/MPAuctionFee" target="_blank">Tatum API documentation</a>
     */
    getAuctionFee: (contractAddress: string) => Promise<number>;
    /**
     * For more details, see <a href="https://tatum.io/apidoc#operation/MPAuctionRecipient" target="_blank">Tatum API documentation</a>
     */
    getAuctionFeeRecipient: (contractAddress: string) => Promise<{
        address?: string;
    }>;
    prepare: {
        /**
         * Sign ETH deploy NFT Auction contract transaction with private keys locally. Nothing is broadcast to the blockchain.
         * @param body content of the transaction to broadcast
         * @param provider url of the ETH Server to connect to. If not set, default public server will be used.
         * @returns transaction data to be broadcast to blockchain, or signatureId in case of Tatum KMS
         */
        deployAuctionSignedTransaction: (body: DeployNftAuction, provider?: string) => Promise<string>;
        auctionUpdateFeeRecipientSignedTransaction: (body: UpdateAuctionFeeRecipient, provider?: string) => Promise<string>;
        /**
         * Create new auction on the auction contract. Before auction, seller must approve spending of the NFT token for the Auction contract.
         * After auction is created, auction contract transfers the asset to the auction smart contract.
         * Only auction for existing NFTs can be created - seller must be owner of the NFT asset.
         * @param body request data
         * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
         * @returns transaction data to be broadcast to blockchain, or signatureId in case of Tatum KMS
         */
        createAuctionSignedTransaction: (body: CreateAuctionEvm, provider?: string) => Promise<string>;
        /**
         * Approve NFT transfer for auction to perform listing of the asset.
         * @param body request data
         * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
         * @returns transaction data to be broadcast to blockchain, or signatureId in case of Tatum KMS
         */
        auctionApproveNftTransferSignedTransaction: (body: ApproveNftTransfer, provider?: string) => Promise<string>;
        /**
         * Approve ERC20 transfer for auction to perform bidding on the asset in the auction.
         * @param body request data
         * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
         * @returns transaction data to be broadcast to blockchain, or signatureId in case of Tatum KMS
         */
        auctionApproveErc20TransferSignedTransaction: (body: ApproveErc20Spending, provider?: string) => Promise<string>;
        /**
         * Bid on the auction. Buyer must either send native assets with this operation, or approve ERC20 token spending before.
         * After auction is sold, it's in a pending state to be processed by the auction. Noone receives the assets unless the auction operator processes that.
         * @param body request data
         * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
         * @returns transaction data to be broadcast to blockchain, or signatureId in case of Tatum KMS
         */
        auctionBidSignedTransaction: (body: AuctionBid, provider?: string) => Promise<string>;
        /**
         * Cancel auction on the auction. Only possible for the seller or the operator. There must be no buyer present for that auction. NFT asset is sent back to the seller.
         * @param body request data
         * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
         * @returns transaction data to be broadcast to blockchain, or signatureId in case of Tatum KMS
         */
        auctionCancelSignedTransaction: (body: CancelSettleAuction, provider?: string) => Promise<string>;
        /**
         * Settle auction. There must be buyer present for that auction. NFT will be sent to the bidder, assets to the seller and fee to the operator.
         * @param body request data
         * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
         * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
         */
        auctionSettleSignedTransaction: (body: CancelSettleAuction, provider?: string) => Promise<string>;
    };
    send: {
        /**
         * Deploy new smart contract for NFT auction logic. Smart contract enables auction operator to create new auction for NFT (ERC-721/1155).
         * Operator can set a fee in percentage, which will be paid on top of the price of the asset.
         * can be offered for native asset - ETH, BSC, etc. - or any ERC20 token - this is configurable during auction creation.
         * Before auction is created, seller must approve transfer of the NFT to the auction contract.
         * Buyer will bid for the asset from the auction using native asset - send assets along the gid() smart contract call, or via ERC20 token.
         * Buyer of the auction must perform approval for the smart contract to access ERC20 token, before the actual bid() method is called.
         * Once there is higher bid than the actual one, the previous bidder's funds will be returned to him and new bidder will be the current winning one.
         * When auction ends, anyone can settle the auction - NFT will be sent to the bidder, assets to the seller and fee to the operator.
         * @param body request data
         * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
         * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
         */
        deployAuctionSignedTransaction: (body: DeployNftAuction, provider?: string) => Promise<import("@tatumio/api-client").TransactionHash | import("@tatumio/api-client").SignatureId>;
        /**
         * Update auction fee recipient.
         * @param body request data
         * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
         * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
         */
        auctionUpdateFeeRecipientSignedTransaction: (body: UpdateAuctionFeeRecipient, provider?: string) => Promise<import("@tatumio/api-client").TransactionHash | import("@tatumio/api-client").SignatureId>;
        /**
         * Create new auction on the auction contract. Before auction, seller must approve spending of the NFT token for the Auction contract.
         * After auction is created, auction contract transfers the asset to the auction smart contract.
         * Only auction for existing NFTs can be created - seller must be owner of the NFT asset.
         * @param body request data
         * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
         * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
         */
        createAuctionSignedTransaction: (body: CreateAuctionEvm, provider?: string) => Promise<import("@tatumio/api-client").TransactionHash | import("@tatumio/api-client").SignatureId>;
        /**
         * Approve NFT transfer for auction to perform listing of the asset.
         * @param body request data
         * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
         * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
         */
        auctionApproveNftTransferSignedTransaction: (body: ApproveNftTransfer, provider?: string) => Promise<import("@tatumio/api-client").TransactionHash | import("@tatumio/api-client").SignatureId>;
        /**
         * Approve ERC20 transfer for auction to perform bidding on the asset in the auction.
         * @param body request data
         * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
         * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
         */
        auctionApproveErc20TransferSignedTransaction: (body: ApproveErc20Spending, provider?: string) => Promise<import("@tatumio/api-client").TransactionHash | import("@tatumio/api-client").SignatureId>;
        auctionBidSignedTransaction: (body: AuctionBid, provider?: string) => Promise<import("@tatumio/api-client").TransactionHash | import("@tatumio/api-client").SignatureId>;
        /**
         * Cancel auction on the auction. Only possible for the seller or the operator. There must be no buyer present for that auction. NFT asset is sent back to the seller.
         * @param body request data
         * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
         * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
         */
        auctionCancelSignedTransaction: (body: CancelSettleAuction, provider?: string) => Promise<import("@tatumio/api-client").TransactionHash | import("@tatumio/api-client").SignatureId>;
        auctionSettleSignedTransaction: (body: CancelSettleAuction, provider?: string) => Promise<import("@tatumio/api-client").TransactionHash | import("@tatumio/api-client").SignatureId>;
    };
};
export declare type DeployNftAuction = FromPrivateKeyOrSignatureId<GenerateAuction> | FromPrivateKeyOrSignatureId<GenerateAuctionCelo>;
export declare type UpdateAuctionFeeRecipient = (FromPrivateKeyOrSignatureId<UpdateFeeRecipient> | FromPrivateKeyOrSignatureId<UpdateFeeRecipientCelo>) & Amount;
export declare type ApproveNftTransfer = FromPrivateKeyOrSignatureId<ApproveNftSpending> | FromPrivateKeyOrSignatureId<ApproveNftSpendingCelo>;
export declare type ApproveErc20Spending = FromPrivateKeyOrSignatureId<ApproveErc20> | FromPrivateKeyOrSignatureId<ApproveCeloErc20>;
export declare type AuctionBid = FromPrivateKeyOrSignatureId<BidOnAuction> | FromPrivateKeyOrSignatureId<BidOnAuctionCelo>;
export declare type CancelSettleAuction = (FromPrivateKeyOrSignatureId<CancelAuction> | FromPrivateKeyOrSignatureId<CancelAuctionCelo>) & Partial<Amount>;
export declare type CreateAuctionEvm = FromPrivateKeyOrSignatureId<CreateAuction> | FromPrivateKeyOrSignatureId<CreateAuctionCelo>;
interface Amount {
    amount: string;
}
export {};
