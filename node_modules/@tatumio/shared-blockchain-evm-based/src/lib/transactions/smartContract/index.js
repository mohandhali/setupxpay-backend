"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.smartContract = exports.smartContractReadMethodInvocation = exports.smartContractWriteMethodInvocation = void 0;
const tslib_1 = require("tslib");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const evm_based_utils_1 = require("../../evm-based.utils");
const api_client_1 = require("@tatumio/api-client");
const smartContractWriteMethodInvocation = ({ body, web3, provider, chain, addressTransformer = (address) => address, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const { fromPrivateKey, fee, params, methodName, methodABI, nonce, amount, signatureId } = body;
    const contractAddress = addressTransformer((_a = body.contractAddress) === null || _a === void 0 ? void 0 : _a.trim());
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract([methodABI]);
    const tx = {
        from: 0,
        to: contractAddress,
        value: amount ? `0x${new bignumber_js_1.default(client.utils.toWei(amount, 'ether')).toString(16)}` : undefined,
        data: contract.methods[methodName](...params).encodeABI(),
        gas: chain === api_client_1.Currency.KLAY ? fee === null || fee === void 0 ? void 0 : fee.gasPrice : undefined,
        nonce,
    };
    return yield evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
exports.smartContractWriteMethodInvocation = smartContractWriteMethodInvocation;
const smartContractReadMethodInvocation = ({ body, web3, provider, addressTransformer = (address) => address, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _b;
    const { params, methodName, methodABI } = body;
    const contractAddress = addressTransformer((_b = body.contractAddress) === null || _b === void 0 ? void 0 : _b.trim());
    const client = web3.getClient(provider);
    const contract = new client.eth.Contract([methodABI], contractAddress);
    return { data: yield contract.methods[methodName](...params).call() };
});
exports.smartContractReadMethodInvocation = smartContractReadMethodInvocation;
const smartContract = ({ web3, broadcastFunction, smartContractApiMethod, addressTransformer = (address) => address, }) => {
    return {
        prepare: {
            /**
             * Sign invoke smart contract transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param options
             * @param options.provider optional url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            smartContractWriteMethodInvocationTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return (0, exports.smartContractWriteMethodInvocation)({ body, web3, provider }); }),
        },
        send: {
            /**
             * Send invoke smart contract transaction to the blockchain.
             * Invoked method only reads from blockchain the data and returns them back.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             */
            smartContractReadMethodInvocationTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return (0, exports.smartContractReadMethodInvocation)({ body, web3, provider, addressTransformer }); }),
            /**
             * Send invoke smart contract transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            smartContractMethodInvocationTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return smartContractApiMethod(body);
                }
                else if (body.methodABI.stateMutability === 'view') {
                    return (0, exports.smartContractReadMethodInvocation)({ body, web3, provider, addressTransformer });
                }
                else {
                    return broadcastFunction({
                        txData: yield (0, exports.smartContractWriteMethodInvocation)({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
        },
    };
};
exports.smartContract = smartContract;
//# sourceMappingURL=index.js.map