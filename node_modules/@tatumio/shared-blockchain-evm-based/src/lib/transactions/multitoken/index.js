"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.multiToken = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@tatumio/api-client");
const contracts_1 = require("../../contracts");
const evm_based_utils_1 = require("../../evm-based.utils");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const shared_core_1 = require("@tatumio/shared-core");
const mintMultiToken = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { nonce, signatureId, fee, tokenId, fromPrivateKey, data, amount } = body;
    const contractAddress = addressTransformer(body.contractAddress.trim());
    const to = addressTransformer(body.to.trim());
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(contracts_1.Erc1155.abi, contractAddress);
    const tx = {
        from: 0,
        to: contractAddress,
        data: contract.methods
            .mint(to, tokenId, `0x${new bignumber_js_1.default(amount).toString(16)}`, data ? data : '0x0')
            .encodeABI(),
        nonce,
    };
    return yield evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const mintMultiTokenBatch = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const { fromPrivateKey, tokenId, nonce, data, fee, amounts, signatureId } = body;
    const contractAddress = addressTransformer(body.contractAddress.trim());
    const to = (_a = body.to) === null || _a === void 0 ? void 0 : _a.map((a) => addressTransformer(a.trim()));
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(contracts_1.Erc1155.abi, contractAddress);
    const amts = amounts.map((amts) => amts.map((amt) => `0x${new bignumber_js_1.default(amt).toString(16)}`));
    const tx = {
        from: 0,
        to: contractAddress,
        data: contract.methods.mintBatch(to, tokenId, amts, data ? data : '0x0').encodeABI(),
        nonce,
    };
    return yield evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const deployMultiToken = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _b;
    const { fromPrivateKey, fee, uri, nonce, signatureId } = body;
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(contracts_1.Erc1155.abi);
    const deploy = contract.deploy({
        arguments: [uri, (_b = body.publicMint) !== null && _b !== void 0 ? _b : false],
        data: contracts_1.Erc1155.bytecode,
    });
    const tx = {
        from: 0,
        data: deploy.encodeABI(),
        nonce,
    };
    return yield evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const transferMultiToken = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { fromPrivateKey, tokenId, fee, nonce, signatureId, amount, data } = body;
    const contractAddress = addressTransformer(body.contractAddress.trim());
    const to = addressTransformer(body.to.trim());
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(contracts_1.Erc1155.abi, contractAddress);
    const tx = {
        from: 0,
        to: contractAddress,
        data: contract.methods
            .safeTransfer(to, tokenId, 
        // TODO: remove ! when type will be fixed
        `0x${new bignumber_js_1.default(amount).toString(16)}`, data ? data : '0x0')
            .encodeABI(),
        nonce,
    };
    return yield evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const transferMultiTokenBatch = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { fromPrivateKey, tokenId, fee, nonce, signatureId, amounts, data } = body;
    const contractAddress = addressTransformer(body.contractAddress.trim());
    const to = addressTransformer(body.to.trim());
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(contracts_1.Erc1155.abi, contractAddress);
    const amts = amounts.map((amt) => `0x${new bignumber_js_1.default(amt).toString(16)}`);
    const tx = {
        from: 0,
        to: contractAddress,
        data: contract.methods
            .safeBatchTransfer(to, tokenId.map((token) => token.trim()), amts, data ? data : '0x0')
            .encodeABI(),
        nonce,
    };
    return yield evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const burnMultiToken = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { fromPrivateKey, tokenId, amount, fee, nonce, signatureId } = body;
    const contractAddress = addressTransformer(body.contractAddress.trim());
    const account = addressTransformer(body.account.trim());
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(contracts_1.Erc1155.abi, contractAddress);
    const tx = {
        from: 0,
        to: contractAddress,
        data: contract.methods.burn(account, tokenId, amount).encodeABI(),
        nonce,
    };
    return yield evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const burnMultiTokenBatch = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { fromPrivateKey, tokenId, amounts, fee, nonce, signatureId } = body;
    const contractAddress = addressTransformer(body.contractAddress.trim());
    const account = addressTransformer(body.account.trim());
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(contracts_1.Erc1155.abi, contractAddress);
    const tx = {
        from: 0,
        to: contractAddress,
        data: contract.methods.burnBatch(account, tokenId, amounts).encodeABI(),
        nonce,
    };
    return yield evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const multiToken = ({ blockchain, web3, broadcastFunction, addressTransformer = (address) => address, }) => {
    const chain = shared_core_1.blockchainHelper.getDefaultCurrencyByBlockchain(blockchain);
    return {
        prepare: {
            /**
             * Sign mint MultiToken transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            mintMultiTokenTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return mintMultiToken({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign mint MultiToken batch transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Ethereum Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            mintMultiTokenBatchTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return mintMultiTokenBatch({ body, web3, provider, addressTransformer }); }),
            /**
             * Send MultiToken transaction with private keys locally. Nothing is broadcast to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            transferMultiTokenTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return transferMultiToken({ body, web3, provider, addressTransformer }); }),
            /**
             * Send MultiToken batch transaction with private keys locally. Nothing is broadcast to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            transferMultiTokenBatchTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return transferMultiTokenBatch({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign deploy MultiToken transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            deployMultiTokenTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return deployMultiToken({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign burn MultiToken transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            burnMultiTokenTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return burnMultiToken({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign burn MultiToken batch transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            burnMultiTokenBatchTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return burnMultiTokenBatch({ body, web3, provider, addressTransformer }); }),
        },
        send: {
            /**
             * Send MultiToken mint transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            mintMultiTokenTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.MultiTokensErc1155OrCompatibleService.mintMultiToken(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield mintMultiToken({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send MultiToken mint batch transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Ethereum Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            mintMultiTokenBatchTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.MultiTokensErc1155OrCompatibleService.mintMultiTokenBatch(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield mintMultiTokenBatch({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send MultiToken transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            transferMultiTokenTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.MultiTokensErc1155OrCompatibleService.transferMultiToken(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield transferMultiToken({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send MultiToken batch transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            transferMultiTokenBatchTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.MultiTokensErc1155OrCompatibleService.transferMultiTokenBatch(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield transferMultiTokenBatch({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             ** Send MultiToken deploy transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            deployMultiTokenTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.MultiTokensErc1155OrCompatibleService.deployMultiToken(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield deployMultiToken({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send MultiToken butn transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            burnMultiTokenTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.MultiTokensErc1155OrCompatibleService.burnMultiToken(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield burnMultiToken({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send MultiToken butn batch transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            burnMultiTokenBatchTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.MultiTokensErc1155OrCompatibleService.burnMultiTokenBatch(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield burnMultiTokenBatch({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
        },
        getTransactionByAddress: api_client_1.MultiTokensErc1155OrCompatibleService.multiTokenGetTransactionByAddress,
        getTransaction: api_client_1.MultiTokensErc1155OrCompatibleService.multiTokenGetTransaction,
        getAddressBalance: api_client_1.MultiTokensErc1155OrCompatibleService.multiTokenGetAddressBalance,
        getBalance: api_client_1.MultiTokensErc1155OrCompatibleService.multiTokenGetBalance,
        getBalanceBatch: api_client_1.MultiTokensErc1155OrCompatibleService.multiTokenGetBalanceBatch,
        getMetadata: api_client_1.MultiTokensErc1155OrCompatibleService.multiTokenGetMetadata,
    };
};
exports.multiToken = multiToken;
//# sourceMappingURL=index.js.map