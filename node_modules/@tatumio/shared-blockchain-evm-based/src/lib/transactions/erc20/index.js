"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.erc20 = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@tatumio/api-client");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const contracts_1 = require("../../contracts");
const evm_based_utils_1 = require("../../evm-based.utils");
const shared_core_1 = require("@tatumio/shared-core");
const mintSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    // TODO: validation
    // await validateBody(body, MintErc20)
    var _a, _b;
    const client = web3.getClient(provider, body.fromPrivateKey);
    const contractAddress = addressTransformer(body.contractAddress.trim());
    const to = addressTransformer(body.to.trim());
    const contract = new client.eth.Contract(contracts_1.Erc20Token.abi, contractAddress);
    const digits = new bignumber_js_1.default(10).pow(yield contract.methods.decimals().call());
    const data = contract.methods
        .mint(to, `0x${new bignumber_js_1.default(body.amount).multipliedBy(digits).toString(16)}`)
        .encodeABI();
    const tx = {
        from: 0,
        to: contractAddress,
        data,
        nonce: body.nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, body.signatureId, body.fromPrivateKey, 
    // @ts-ignore
    (_a = body.fee) === null || _a === void 0 ? void 0 : _a.gasLimit, // @TODO openapi bug
    // @ts-ignore
    (_b = body.fee) === null || _b === void 0 ? void 0 : _b.gasPrice, // @TODO openapi bug
    provider);
});
const burnSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    // TODO: validation
    // await validateBody(body, BurnErc20)
    var _c, _d;
    const client = web3.getClient(provider, body.fromPrivateKey);
    const contractAddress = addressTransformer(body.contractAddress.trim());
    // TODO: any type
    const contract = new client.eth.Contract(contracts_1.Erc20Token.abi, contractAddress);
    const digits = new bignumber_js_1.default(10).pow(yield contract.methods.decimals().call());
    const data = contract.methods
        .burn(`0x${new bignumber_js_1.default(body.amount).multipliedBy(digits).toString(16)}`)
        .encodeABI();
    const tx = {
        from: 0,
        to: contractAddress,
        data,
        nonce: body.nonce,
    };
    if (body.fromPrivateKey) {
        yield evm_based_utils_1.evmBasedUtils.validateErc20Balance(client, body.fromPrivateKey, contractAddress, body.amount);
    }
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, body.signatureId, body.fromPrivateKey, (_c = body.fee) === null || _c === void 0 ? void 0 : _c.gasLimit, (_d = body.fee) === null || _d === void 0 ? void 0 : _d.gasPrice, provider);
});
const transferSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    // TODO
    // await validateBody(body, TransferErc20)
    var _e, _f;
    const client = web3.getClient(provider, body.fromPrivateKey);
    const contractAddress = addressTransformer(body.contractAddress.trim());
    const to = addressTransformer(body.to.trim());
    const decimals = new bignumber_js_1.default(10).pow(body.digits);
    // TODO
    const data = new client.eth.Contract(contracts_1.Erc20Token.abi, contractAddress).methods
        .transfer(to, `0x${new bignumber_js_1.default(body.amount).multipliedBy(decimals).toString(16)}`)
        .encodeABI();
    const tx = {
        from: 0,
        to: contractAddress,
        data,
        nonce: body.nonce,
    };
    if (body.fromPrivateKey) {
        yield evm_based_utils_1.evmBasedUtils.validateErc20Balance(client, body.fromPrivateKey, contractAddress, body.amount);
    }
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, body.signatureId, body.fromPrivateKey, (_e = body.fee) === null || _e === void 0 ? void 0 : _e.gasLimit, (_f = body.fee) === null || _f === void 0 ? void 0 : _f.gasPrice, provider);
});
const deploySignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _g, _h;
    // TODO: validation
    // await validateBody(body, DeployErc20)
    const { name, symbol, supply, digits, fromPrivateKey, nonce, signatureId, totalCap } = body;
    const client = web3.getClient(provider, fromPrivateKey);
    const address = addressTransformer(body.address.trim());
    // TODO
    const contract = new client.eth.Contract(contracts_1.Erc20Token.abi);
    const deploy = contract.deploy({
        data: contracts_1.Erc20Token.bytecode,
        arguments: [
            name,
            symbol,
            address,
            digits,
            `0x${new bignumber_js_1.default(totalCap || supply).multipliedBy(new bignumber_js_1.default(10).pow(digits)).toString(16)}`,
            `0x${new bignumber_js_1.default(supply).multipliedBy(new bignumber_js_1.default(10).pow(digits)).toString(16)}`,
        ],
    });
    const tx = {
        from: undefined,
        data: deploy.encodeABI(),
        nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, (_g = body.fee) === null || _g === void 0 ? void 0 : _g.gasLimit, (_h = body.fee) === null || _h === void 0 ? void 0 : _h.gasPrice, provider);
});
const decimals = (contractAddress, web3, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const client = web3.getClient(provider);
    return new client.eth.Contract(contracts_1.Erc20Token.abi, contractAddress).methods.decimals().call();
});
const approveSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _j, _k;
    const amount = new bignumber_js_1.default(body.amount)
        .multipliedBy(new bignumber_js_1.default(10).pow(yield decimals(body.contractAddress, web3, provider)))
        .toString(16);
    const contractAddress = addressTransformer(body.contractAddress.trim());
    const spender = addressTransformer(body.spender.trim());
    const params = [spender, `0x${amount}`];
    const client = web3.getClient(provider, body.fromPrivateKey);
    // TODO remove any type
    const data = new client.eth.Contract(contracts_1.Erc20Token.abi, contractAddress).methods
        .approve(...params)
        .encodeABI();
    const tx = {
        from: 0,
        data,
        to: contractAddress,
        nonce: body.nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, body.signatureId, body.fromPrivateKey, (_j = body.fee) === null || _j === void 0 ? void 0 : _j.gasLimit, (_k = body.fee) === null || _k === void 0 ? void 0 : _k.gasPrice, provider);
});
const erc20 = ({ blockchain, web3, broadcastFunction, addressTransformer = evm_based_utils_1.AddressTransformerDefault, }) => {
    const chain = shared_core_1.blockchainHelper.getDefaultCurrencyByBlockchain(blockchain);
    return {
        /**
         * Get Decimals for the ERC20 token
         * @param contractAddress address of the token
         * @param provider optional provider
         */
        decimals: (contractAddress, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const web3Client = web3.getClient(provider);
            // TODO: any type
            return new web3Client.eth.Contract(contracts_1.Erc20Token.abi, addressTransformer(contractAddress)).methods
                .decimals()
                .call();
        }),
        prepare: {
            /**
             * Sign deploy erc20 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            deploySignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return deploySignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign transfer erc20 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            transferSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return transferSignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign mint erc20 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            mintSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return mintSignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign burn erc20 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            burnSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return burnSignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Prepare approve ERC20 signed transaction.
             * @param body body of the approve operation
             * @param provider optional Web3 provider
             */
            approveSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return approveSignedTransaction({ body, web3, provider, addressTransformer }); }),
        },
        send: {
            /**
             * Send deploy erc20 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            deploySignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.FungibleTokensErc20OrCompatibleService.erc20Deploy(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield deploySignedTransaction({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send transfer erc20 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            transferSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.FungibleTokensErc20OrCompatibleService.erc20Transfer(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield transferSignedTransaction({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send mint erc20 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            mintSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.FungibleTokensErc20OrCompatibleService.erc20Mint(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield mintSignedTransaction({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send burn erc20 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            burnSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.FungibleTokensErc20OrCompatibleService.erc20Burn(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield burnSignedTransaction({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send approve erc20 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            approveSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.FungibleTokensErc20OrCompatibleService.erc20Approve(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield approveSignedTransaction({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
        },
    };
};
exports.erc20 = erc20;
//# sourceMappingURL=index.js.map