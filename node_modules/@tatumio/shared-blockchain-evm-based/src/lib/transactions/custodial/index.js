"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.custodial = void 0;
const tslib_1 = require("tslib");
const shared_core_1 = require("@tatumio/shared-core");
const evm_based_custodial_1 = require("../../services/evm-based.custodial");
const smartContract_1 = require("../smartContract");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const contracts_1 = require("../../contracts");
const evm_based_smartContract_1 = require("../../services/evm-based.smartContract");
const evm_based_utils_1 = require("../../evm-based.utils");
const api_client_1 = require("@tatumio/api-client");
const shared_abstract_sdk_1 = require("@tatumio/shared-abstract-sdk");
const transferFromCustodialWallet = ({ body, web3, testnet, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c;
    const normalizedBody = Object.assign(Object.assign({}, body), { custodialAddress: addressTransformer((_a = body.custodialAddress) === null || _a === void 0 ? void 0 : _a.trim()), recipient: addressTransformer((_b = body.recipient) === null || _b === void 0 ? void 0 : _b.trim()), tokenAddress: addressTransformer((_c = body.tokenAddress) === null || _c === void 0 ? void 0 : _c.trim()) });
    return (0, evm_based_custodial_1.evmBasedCustodial)().prepareTransferFromCustodialWalletAbstract(normalizedBody, web3, evm_based_utils_1.evmBasedUtils.decimals, smartContract_1.smartContractWriteMethodInvocation, 18, testnet, provider);
});
const batchTransferFromCustodialWallet = ({ body, web3, testnet, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _d, _e;
    const normalizedBody = Object.assign(Object.assign({}, body), { custodialAddress: addressTransformer((_d = body.custodialAddress) === null || _d === void 0 ? void 0 : _d.trim()), recipient: body.recipient.map((r) => addressTransformer(r === null || r === void 0 ? void 0 : r.trim())), tokenAddress: (_e = body.tokenAddress) === null || _e === void 0 ? void 0 : _e.map((t) => addressTransformer(t === null || t === void 0 ? void 0 : t.trim())) });
    return (0, evm_based_custodial_1.evmBasedCustodial)().prepareBatchTransferFromCustodialWalletAbstract(normalizedBody, web3, evm_based_utils_1.evmBasedUtils.decimals, smartContract_1.smartContractWriteMethodInvocation, 18, testnet, provider);
});
const approveFromCustodialWallet = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _f, _g;
    const custodialAddress = addressTransformer((_f = body.custodialAddress) === null || _f === void 0 ? void 0 : _f.trim());
    const tokenAddress = addressTransformer((_g = body.tokenAddress) === null || _g === void 0 ? void 0 : _g.trim());
    // ContractType FUNGIBLE_TOKEN = 0
    const decimals = body.contractType === 0 ? yield evm_based_utils_1.evmBasedUtils.decimals(tokenAddress, web3, provider) : 0;
    const params = [
        tokenAddress,
        body.contractType,
        body.spender,
        `0x${new bignumber_js_1.default(body.amount || 0).multipliedBy(new bignumber_js_1.default(10).pow(decimals)).toString(16)}`,
        `0x${new bignumber_js_1.default(body.tokenId || 0).toString(16)}`,
    ];
    delete body.amount;
    return yield (0, evm_based_smartContract_1.evmBasedSmartContract)(web3).helperPrepareSCCall(Object.assign(Object.assign({}, body), { contractAddress: custodialAddress }), 'approve', params, provider, contracts_1.CustodialFullTokenWallet.abi);
});
const generateCustodialBatch = (body) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const request = yield api_client_1.ApiServices.blockchain.gasPump.generateCustodialWalletBatch(body);
    if (request)
        return request.txId;
    else
        throw new Error('Unable to generate custodial wallet address.');
});
const custodialWalletBatch = ({ body, web3, testnet, provider, addressTransformer = evm_based_utils_1.AddressTransformerDefault, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { params, methodName, bodyWithContractAddress } = yield (0, evm_based_custodial_1.evmBasedCustodial)().prepareCustodialWalletBatchAbstract({ body, testnet, addressTransformer });
    return yield (0, evm_based_smartContract_1.evmBasedSmartContract)(web3).helperPrepareSCCall(bodyWithContractAddress, methodName, params, provider, [shared_core_1.CUSTODIAL_PROXY_ABI]);
});
const custodial = ({ web3, broadcastFunction, addressTransformer = evm_based_utils_1.AddressTransformerDefault, }) => {
    return {
        prepare: {
            /**
             * Prepare signed transaction from the custodial SC wallet.
             * @param testnet chain to work with
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            transferFromCustodialWallet: (body, provider, testnet) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                return evm_based_utils_1.evmBasedUtils.tryCatch(() => transferFromCustodialWallet({ body, web3, testnet, provider, addressTransformer }), shared_abstract_sdk_1.SdkErrorCode.EVM_CUSTODIAL_CANNOT_PREPARE_TRANSFER_TX);
            }),
            /**
             * Prepare signed batch transaction from the custodial SC wallet.
             * @param testnet chain to work with
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            batchTransferFromCustodialWallet: (body, provider, testnet) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                return evm_based_utils_1.evmBasedUtils.tryCatch(() => batchTransferFromCustodialWallet({ body, web3, testnet, provider, addressTransformer }), shared_abstract_sdk_1.SdkErrorCode.EVM_CUSTODIAL_CANNOT_PREPARE_TRANSFER_BATCH_TX);
            }),
            /**
             * Prepare signed approve transaction from the custodial SC wallet.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            approveFromCustodialWallet: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                return evm_based_utils_1.evmBasedUtils.tryCatch(() => approveFromCustodialWallet({ body, web3, provider, addressTransformer }), shared_abstract_sdk_1.SdkErrorCode.EVM_CUSTODIAL_CANNOT_PREPARE_APPROVE_TX);
            }),
            /**
             * Generate new smart contract based custodial wallet. This wallet is able to receive any type of assets, but transaction costs connected to the withdrawal
             * of assets is covered by the deployer.
             * @param testnet chain to work with
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            custodialWalletBatch: (body, provider, testnet) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                return evm_based_utils_1.evmBasedUtils.tryCatch(() => custodialWalletBatch({ body, web3, testnet, provider, addressTransformer }), shared_abstract_sdk_1.SdkErrorCode.EVM_CUSTODIAL_CANNOT_PREPARE_DEPLOY_TX);
            }),
        },
        send: {
            /**
             * Send signed transaction from the custodial SC wallet.
             * @param testnet chain to work with
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            transferFromCustodialWallet: (body, provider, testnet) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.GasPumpService.transferCustodialWallet(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield transferFromCustodialWallet({ body, web3, testnet, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send signed batch transaction from the custodial SC wallet.
             * @param testnet chain to work with
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            batchTransferFromCustodialWallet: (body, provider, testnet) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.GasPumpService.transferCustodialWalletBatch(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield batchTransferFromCustodialWallet({
                            body,
                            web3,
                            testnet,
                            provider,
                            addressTransformer,
                        }),
                    });
                }
            }),
            /**
             * Send signed approve transaction from the custodial SC wallet.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            approveFromCustodialWallet: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.GasPumpService.approveTransferCustodialWallet(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield approveFromCustodialWallet({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Generate new smart contract based custodial wallet. This wallet is able to receive any type of assets, but transaction costs connected to the withdrawal
             * of assets is covered by the deployer.
             * @param testnet chain to work with
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            custodialWalletBatch: (body, provider, testnet) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if ('feesCovered' in body) {
                    return generateCustodialBatch(body);
                }
                else if ('signatureId' in body) {
                    return api_client_1.GasPumpService.generateCustodialWalletBatch(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield custodialWalletBatch({ body, web3, testnet, provider, addressTransformer }),
                    });
                }
            }),
        },
    };
};
exports.custodial = custodial;
//# sourceMappingURL=index.js.map