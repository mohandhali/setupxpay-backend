"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.marketplace = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@tatumio/api-client");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const contracts_1 = require("../../contracts");
const evm_based_utils_1 = require("../../evm-based.utils");
const erc20_1 = require("../erc20");
const evm_based_auction_1 = require("../../services/evm-based.auction");
/** Deploy contract (generate Marketplace) */
const generateMarketplace = ({ body, web3, provider, addressTransformer = (address) => address, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const client = web3.getClient(provider, body.fromPrivateKey);
    const { fromPrivateKey, signatureId, nonce, marketplaceFee, fee } = body;
    const feeRecipient = addressTransformer((_a = body.feeRecipient) === null || _a === void 0 ? void 0 : _a.trim());
    // TODO: remove any type
    const data = new client.eth.Contract(contracts_1.ListingSmartContract.abi)
        .deploy({
        arguments: [marketplaceFee, feeRecipient],
        data: contracts_1.ListingSmartContract.bytecode,
    })
        .encodeABI();
    const tx = {
        from: 0,
        data,
        nonce: nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
/* Update Marketplace fee */
const updateFee = ({ body, web3, provider, addressTransformer = (address) => address, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _b;
    const client = web3.getClient(provider, body.fromPrivateKey);
    const { fromPrivateKey, nonce, signatureId, fee, marketplaceFee } = body;
    const contractAddress = addressTransformer((_b = body.contractAddress) === null || _b === void 0 ? void 0 : _b.trim());
    const smartContractMethodName = 'setMarketplaceFee';
    // TODO remove any type
    const data = new client.eth.Contract(contracts_1.ListingSmartContract.abi).methods[smartContractMethodName]([
        `0x${new bignumber_js_1.default(marketplaceFee).toString(16)}`,
    ]).encodeABI();
    if (contractAddress) {
        const tx = {
            from: 0,
            data,
            to: contractAddress,
            nonce: nonce,
        };
        return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
    }
    throw new Error('Contract address should not be empty!');
});
/** Update Marketplace fee recipient */
const updateFeeRecipient = ({ body, web3, provider, addressTransformer = (address) => address, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _c, _d;
    const client = web3.getClient(provider, body.fromPrivateKey);
    const { signatureId, fromPrivateKey, nonce, fee } = body;
    const contractAddress = addressTransformer((_c = body.contractAddress) === null || _c === void 0 ? void 0 : _c.trim());
    const feeRecipient = addressTransformer((_d = body.feeRecipient) === null || _d === void 0 ? void 0 : _d.trim());
    const smartContractMethodName = 'setMarketplaceFeeRecipient';
    // TODO remove any type
    const data = new client.eth.Contract(contracts_1.ListingSmartContract.abi).methods[smartContractMethodName]([
        feeRecipient,
    ]).encodeABI();
    if (contractAddress) {
        const tx = {
            from: 0,
            data,
            to: contractAddress,
            nonce: nonce,
        };
        return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
    }
    throw new Error('Contract address should not be empty!');
});
/** Buy Marketplace asset */
const buyAsset = ({ body, web3, provider, addressTransformer = evm_based_utils_1.AddressTransformerDefault, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _e, _f, _g;
    const client = web3.getClient(provider, body.fromPrivateKey);
    const { listingId, nonce, signatureId, fromPrivateKey, fee } = body;
    const buyer = addressTransformer((_e = body.buyer) === null || _e === void 0 ? void 0 : _e.trim());
    const contractAddress = addressTransformer((_f = body.contractAddress) === null || _f === void 0 ? void 0 : _f.trim());
    const erc20Address = addressTransformer(body.erc20Address ? (_g = body.erc20Address) === null || _g === void 0 ? void 0 : _g.trim() : '0x0000000000000000000000000000000000000000');
    const smartContractParams = [listingId, erc20Address];
    let smartContractMethodName = 'buyAssetFromListing';
    if (buyer) {
        smartContractMethodName = 'buyAssetFromListingForExternalBuyer';
        smartContractParams.push(buyer);
    }
    // TODO remove any type
    const data = new client.eth.Contract(contracts_1.ListingSmartContract.abi).methods[smartContractMethodName](...smartContractParams).encodeABI();
    if (contractAddress) {
        const tx = {
            from: 0,
            data,
            to: contractAddress,
            nonce: nonce,
        };
        return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
    }
    throw new Error('Contract address should not be empty!');
});
/** Sell Marketplace asset */
const sellAsset = ({ body, web3, provider, addressTransformer = (address) => address, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _h, _j, _k, _l;
    const client = web3.getClient(provider, body.fromPrivateKey);
    const seller = addressTransformer((_h = body.seller) === null || _h === void 0 ? void 0 : _h.trim());
    const nftAddress = addressTransformer((_j = body.nftAddress) === null || _j === void 0 ? void 0 : _j.trim());
    const contractAddress = addressTransformer((_k = body.contractAddress) === null || _k === void 0 ? void 0 : _k.trim());
    const erc20Address = addressTransformer(body.erc20Address ? (_l = body.erc20Address) === null || _l === void 0 ? void 0 : _l.trim() : '0x0000000000000000000000000000000000000000');
    const { listingId, amount, tokenId, price, isErc721, signatureId, fromPrivateKey, nonce, fee } = body;
    const smartContractMethodName = 'createListing';
    const smartContractParams = [
        listingId,
        isErc721,
        nftAddress,
        tokenId,
        price,
        seller,
        amount !== null && amount !== void 0 ? amount : '0',
        erc20Address,
    ];
    // TODO remove any type
    const data = new client.eth.Contract(contracts_1.ListingSmartContract.abi).methods[smartContractMethodName](...smartContractParams).encodeABI();
    if (contractAddress) {
        const tx = {
            from: 0,
            data,
            to: contractAddress.trim(),
            nonce: nonce,
        };
        return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
    }
    throw new Error('Contract address should not be empty!');
});
/** Cancel Marketplace asset listing */
const cancelListing = ({ body, web3, provider, addressTransformer = (address) => address, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _m;
    const client = web3.getClient(provider, body.fromPrivateKey);
    const { listingId, nonce, signatureId, fromPrivateKey, fee } = body;
    const contractAddress = addressTransformer((_m = body.contractAddress) === null || _m === void 0 ? void 0 : _m.trim());
    const smartContractMethodName = 'cancelListing';
    // TODO remove any type
    const data = new client.eth.Contract(contracts_1.ListingSmartContract.abi).methods[smartContractMethodName](listingId).encodeABI();
    if (contractAddress) {
        const tx = {
            from: 0,
            data,
            to: contractAddress,
            nonce: nonce,
        };
        return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
    }
    throw new Error('Contract address should not be empty!');
});
const marketplace = ({ web3, broadcastFunction, blockchain, addressTransformer = (address) => address, }) => {
    return {
        prepare: {
            /**
             * Approve ERC20 spending for marketplace to perform buy with ERC20 token.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            approveErc20Spending: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                return (0, erc20_1.erc20)({
                    web3,
                    broadcastFunction,
                    addressTransformer,
                    blockchain,
                }).prepare.approveSignedTransaction(body, provider);
            }),
            /**
             * Approve NFT transfer for listing.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns transaction data to be broadcast to blockchain, or signatureId in case of Tatum KMS
             */
            approveSpending: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                return (0, evm_based_auction_1.evmBasedAuction)({
                    web3,
                    broadcastFunction,
                    blockchain,
                }).prepare.auctionApproveNftTransferSignedTransaction(body, provider);
            }),
            /**
             * Prepare signed transaction for deploy new smart contract for NFT marketplace logic. Smart contract enables marketplace operator to create new listing for NFT (ERC-721/1155).
             * Operator can set a fee in percentage, which will be paid on top of the price of the asset.
             * Listing can be offered for native asset - ETH, BSC, etc. - or any ERC20 token - this is configurable during listing creation.
             * Once the listing is created, seller must send the NFT asset to the smart contract.
             * Buyer will buy the asset from the listing using native asset - send assets along the buyAssetFromListing() smart contract call, or via ERC20 token.
             * Buyer of the listing must perform approval for the smart contract to access ERC20 token, before the actual buyAssetFromListing() method is called.
             * Once both assets - from buyer and seller - are in the smart contract, NFT is sent to the buyer, price is sent to the seller
             * and marketplace fee is set to the operator.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            generateMarketplace: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return generateMarketplace({ body, web3, provider, addressTransformer }); }),
            /**
             * Update marketplace fee.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            updateFee: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return updateFee({ body, web3, provider, addressTransformer }); }),
            /**
             * Update marketplace fee recipient.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            updateFeeRecipient: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return updateFeeRecipient({ body, web3, provider, addressTransformer }); }),
            /**
             * Buy listing on the marketplace. Buyer must either send native assets with this operation, or approve ERC20 token spending before.
             * After listing is sold, it's in a pending state to be processed by the marketplace. Noone receives the assets unless the marketplace operator processes that.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            buyMarketplaceListing: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return buyAsset({ body, web3, provider, addressTransformer }); }),
            /**
             * Create new listing on the marketplace. Only marketplace operator can establish those on behalf of the seller of the NFT.
             * After listing is created, seller must approve the asset for spending to the marketplace smart contract.
             * Only listing for existing NFTs can be created - seller must be owner of the NFT asset.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            sellMarketplaceListing: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return sellAsset({ body, web3, provider, addressTransformer }); }),
            /**
             * Cancel listing on the marketplace. Only possible for the seller or the operator. There must be no buyer present for that listing. NFT asset is sent back to the seller.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            cancelMarketplaceListing: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return cancelListing({ body, web3, provider, addressTransformer }); }),
        },
        send: {
            /**
             * Approve ERC20 spending for marketplace to perform buy with ERC20 token.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            approveErc20Spending: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.FungibleTokensErc20OrCompatibleService.erc20Approve(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield (0, erc20_1.erc20)({
                            web3,
                            broadcastFunction,
                            addressTransformer,
                            blockchain,
                        }).prepare.approveSignedTransaction(body, provider),
                    });
                }
            }),
            /**
             * Approve NFT transfer for listing.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            auctionApproveNftTransferSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    // TODO: find better type
                    return api_client_1.AuctionService.approveNftAuctionSpending(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield (0, evm_based_auction_1.evmBasedAuction)({
                            web3,
                            broadcastFunction,
                            blockchain,
                        }).prepare.auctionApproveNftTransferSignedTransaction(body, provider),
                    });
                }
            }),
            /**
             * Deploy new smart contract for NFT marketplace logic. Smart contract enables marketplace operator to create new listing for NFT (ERC-721/1155).
             * Operator can set a fee in percentage, which will be paid on top of the price of the asset.
             * Listing can be offered for native asset - ETH, BSC, etc. - or any ERC20 token - this is configurable during listing creation.
             * Once the listing is created, seller must send the NFT asset to the smart contract.
             * Buyer will buy the asset from the listing using native asset - send assets along the buyAssetFromListing() smart contract call, or via ERC20 token.
             * Buyer of the listing must perform approval for the smart contract to access ERC20 token, before the actual buyAssetFromListing() method is called.
             * Once both assets - from buyer and seller - are in the smart contract, NFT is sent to the buyer, price is sent to the seller
             * and marketplace fee is set to the operator.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            generateMarketplace: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    // TODO: find better type
                    return api_client_1.MarketplaceService.generateMarketplace(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield generateMarketplace({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Update marketplace fee.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            updateFee: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    // TODO: find better type
                    return api_client_1.MarketplaceService.updateFee(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield updateFee({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Update marketplace fee recipient.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            updateFeeRecipient: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    // TODO: find better type
                    return api_client_1.MarketplaceService.updateFeeRecipient(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield updateFeeRecipient({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Buy listing on the marketplace. Buyer must either send native assets with this operation, or approve ERC20 token spending before.
             * After listing is sold, it's in a pending state to be processed by the marketplace. Noone receives the assets unless the marketplace operator processes that.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            buyMarketplaceListing: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    // TODO: find better type
                    return api_client_1.MarketplaceService.buyAssetOnMarketplace(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield buyAsset({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Create new listing on the marketplace. Only marketplace operator can establish those on behalf of the seller of the NFT.
             * After listing is created, seller must approve the asset for spending to the marketplace smart contract.
             * Only listing for existing NFTs can be created - seller must be owner of the NFT asset.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            sellMarketplaceListing: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    // TODO: find better type
                    return api_client_1.MarketplaceService.sellAssetOnMarketplace(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield sellAsset({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Cancel listing on the marketplace. Only possible for the seller or the operator. There must be no buyer present for that listing. NFT asset is sent back to the seller.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            cancelMarketplaceListing: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    // TODO: find better type
                    return api_client_1.MarketplaceService.cancelSellMarketplaceListing(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield cancelListing({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
        },
    };
};
exports.marketplace = marketplace;
//# sourceMappingURL=index.js.map