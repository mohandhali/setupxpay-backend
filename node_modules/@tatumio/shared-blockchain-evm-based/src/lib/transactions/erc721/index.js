"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.erc721 = void 0;
const tslib_1 = require("tslib");
const evm_based_utils_1 = require("../../evm-based.utils");
const api_client_1 = require("@tatumio/api-client");
const erc721General_1 = require("../../contracts/erc721General");
const erc721Cashback_1 = require("../../contracts/erc721Cashback");
const shared_core_1 = require("@tatumio/shared-core");
const evm_based_sdk_errors_1 = require("../../evm-based.sdk.errors");
const shared_abstract_sdk_1 = require("@tatumio/shared-abstract-sdk");
const mintSignedTransactionMinter = (body) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const request = yield api_client_1.NftErc721OrCompatibleService.nftMintErc721(body);
    if (request)
        return request.txId;
    else
        throw new Error('Unable to mint NFT with a minter.');
});
const mintSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { nonce, signatureId, fee, tokenId, url, fromPrivateKey } = body;
    const contractAddress = addressTransformer(body.contractAddress.trim());
    const to = addressTransformer(body.to.trim());
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(erc721Cashback_1.Erc721Token_Cashback.abi, contractAddress);
    const alreadyMinted = yield evm_based_utils_1.evmBasedUtils.alreadyMinted(contract, tokenId);
    if (alreadyMinted) {
        throw new evm_based_sdk_errors_1.EvmBasedSdkError({ code: shared_abstract_sdk_1.SdkErrorCode.EVM_ERC721_CANNOT_PREPARE_MINT_ALREADY_MINTED });
    }
    if (contractAddress) {
        const tx = {
            from: 0,
            to: contractAddress,
            data: contract.methods.mintWithTokenURI(to, tokenId, url).encodeABI(),
            nonce: nonce,
        };
        return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
    }
    throw new Error('Contract address should not be empty');
});
const mintMultipleSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const { fromPrivateKey, tokenId, url, nonce, signatureId, fee } = body;
    const contractAddress = addressTransformer((_a = body.contractAddress) === null || _a === void 0 ? void 0 : _a.trim());
    const to = (_b = body.to) === null || _b === void 0 ? void 0 : _b.map((a) => addressTransformer(a === null || a === void 0 ? void 0 : a.trim()));
    const client = yield web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(erc721Cashback_1.Erc721Token_Cashback.abi, contractAddress);
    const tx = {
        from: undefined,
        to: contractAddress,
        data: contract.methods.mintMultiple(to, tokenId, url).encodeABI(),
        nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const burnSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _c;
    const { fromPrivateKey, tokenId, fee, nonce, signatureId } = body;
    const contractAddress = addressTransformer((_c = body.contractAddress) === null || _c === void 0 ? void 0 : _c.trim());
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(erc721Cashback_1.Erc721Token_Cashback.abi, contractAddress);
    const tx = {
        from: 0,
        to: contractAddress,
        data: contract.methods.burn(tokenId).encodeABI(),
        nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const addMinterSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _d, _e;
    const { fromPrivateKey, fee, nonce, signatureId } = body;
    const contractAddress = addressTransformer((_d = body.contractAddress) === null || _d === void 0 ? void 0 : _d.trim());
    const minter = addressTransformer((_e = body.minter) === null || _e === void 0 ? void 0 : _e.trim());
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(erc721General_1.Erc721Token_General.abi, contractAddress);
    const tx = {
        from: 0,
        to: contractAddress,
        data: contract.methods
            .grantRole('0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6', minter)
            .encodeABI(),
        nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const transferSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _f, _g;
    const { fromPrivateKey, tokenId, fee, nonce, signatureId } = body;
    const contractAddress = addressTransformer((_f = body.contractAddress) === null || _f === void 0 ? void 0 : _f.trim());
    const to = addressTransformer((_g = body.to) === null || _g === void 0 ? void 0 : _g.trim());
    const client = yield web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(erc721Cashback_1.Erc721Token_Cashback.abi, contractAddress);
    const dataBytes = '';
    const tokenData = contract.methods.safeTransfer(to, tokenId).encodeABI();
    const tx = {
        from: 0,
        to: contractAddress,
        data: tokenData,
        nonce,
        value: undefined,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const deploySignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { fromPrivateKey, fee, name, symbol, nonce, signatureId, publicMint } = body;
    const client = yield web3.getClient(provider, fromPrivateKey);
    const abi = erc721General_1.Erc721Token_General.abi;
    const deployData = erc721General_1.Erc721Token_General.bytecode;
    const contract = new client.eth.Contract(abi);
    const deploy = contract.deploy({
        arguments: [name, symbol, publicMint !== null && publicMint !== void 0 ? publicMint : false],
        data: deployData,
    });
    const tx = {
        from: 0,
        data: deploy.encodeABI(),
        nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const isUsingNftMinter = (body) => {
    return 'minter' in body;
};
const erc721 = ({ blockchain, web3, broadcastFunction, addressTransformer = (address) => address, }) => {
    const chain = shared_core_1.blockchainHelper.getDefaultCurrencyByBlockchain(blockchain);
    return {
        prepare: {
            /**
             * Sign mint ERC 721 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            mintSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return mintSignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign mint multiple ERC 721 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            mintMultipleSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return mintMultipleSignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign burn ERC 721 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            burnSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return burnSignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign transfer ERC 721 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            transferSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return transferSignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign deploy ERC 721 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            deploySignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return deploySignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign add minter to ERC 721 with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            addMinterSignedTransaction: (body, provider) => addMinterSignedTransaction({ body, web3, provider, addressTransformer }),
        },
        send: {
            /**
             * Send BEP721 mint transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            mintSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (isUsingNftMinter(body)) {
                    return mintSignedTransactionMinter(body);
                }
                else if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftMintErc721(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield mintSignedTransaction({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send BEP721 mint multiple transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            mintMultipleSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftMintMultipleErc721(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield mintMultipleSignedTransaction({
                            body,
                            web3,
                            provider,
                            addressTransformer,
                        }),
                    });
                }
            }),
            /**
             * Send BEP721 burn transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the  Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            burnSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftBurnErc721(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield burnSignedTransaction({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send BEP721 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            transferSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftTransferErc721(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield transferSignedTransaction({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send BEP721 deploy to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            deploySignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftDeployErc721(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield deploySignedTransaction({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
        },
    };
};
exports.erc721 = erc721;
//# sourceMappingURL=index.js.map