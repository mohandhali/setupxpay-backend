"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.native = void 0;
const tslib_1 = require("tslib");
const evm_based_utils_1 = require("../../evm-based.utils");
const transferSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    // TODO
    // await validateBody(body, ChainTransferNative)
    var _a, _b;
    const client = web3.getClient(provider, body.fromPrivateKey);
    const to = addressTransformer(body.to.trim());
    const tx = {
        from: 0,
        to: to,
        data: body.data,
        value: evm_based_utils_1.evmBasedUtils.transformToWei(body.amount),
        nonce: body.nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, body.signatureId, body.fromPrivateKey, (_a = body.fee) === null || _a === void 0 ? void 0 : _a.gasLimit, (_b = body.fee) === null || _b === void 0 ? void 0 : _b.gasPrice, provider);
});
const native = ({ web3, broadcastFunction, transferApiMethod, addressTransformer = evm_based_utils_1.AddressTransformerDefault, }) => {
    return {
        prepare: {
            /**
             * Sign transfer of native asset transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            transferSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return transferSignedTransaction({ body, web3, provider, addressTransformer }); }),
        },
        send: {
            /**
             * Send transfer of native asset transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            transferSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return transferApiMethod(body);
                }
                else {
                    return broadcastFunction({
                        txData: yield transferSignedTransaction({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
        },
    };
};
exports.native = native;
//# sourceMappingURL=index.js.map