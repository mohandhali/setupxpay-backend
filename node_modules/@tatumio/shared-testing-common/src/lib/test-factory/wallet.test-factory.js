"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.walletTestFactory = void 0;
const tslib_1 = require("tslib");
require("jest/index");
const shared_testing_1 = require("../shared-testing");
exports.walletTestFactory = {
    generateBlockchainWallet: (sdk, testData, givenMnemonic = shared_testing_1.TEST_DATA.MNEMONIC, skipInvalidMnemonic = false) => {
        describe('mainnet', () => {
            it('valid', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                const { mnemonic, xpub } = yield sdk.generateWallet(givenMnemonic);
                expect(mnemonic).toBe(shared_testing_1.TEST_DATA.MNEMONIC);
                expect(xpub).toBe(testData.MAINNET.XPUB);
            }));
            it('without input mnemonic', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                const { mnemonic, xpub } = yield sdk.generateWallet();
                expect(mnemonic.length).toBeGreaterThan(0);
                expect(xpub).toMatch(testData.MAINNET.XPUB_REGEX);
            }));
            it('invalid input mnemonic', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                const wrongMnemonic = 'wrongmnemonic';
                const { mnemonic, xpub } = yield sdk.generateWallet(wrongMnemonic);
                expect(mnemonic).toBe(wrongMnemonic);
                expect(xpub).toMatch(testData.MAINNET.XPUB_REGEX);
            }));
        });
        describe('testnet', () => {
            it('valid', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                const { mnemonic, xpub } = yield sdk.generateWallet(givenMnemonic, { testnet: true });
                expect(mnemonic).toBe(shared_testing_1.TEST_DATA.MNEMONIC);
                expect(xpub).toBe(testData.TESTNET.XPUB);
            }));
            it('without input mnemonic', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                const { mnemonic, xpub } = yield sdk.generateWallet(undefined, {
                    testnet: true,
                });
                expect(mnemonic.length).toBeGreaterThan(0);
                expect(xpub).toMatch(testData.TESTNET.XPUB_REGEX);
            }));
            it('invalid input mnemonic', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                const wrongMnemonic = 'wrongmnemonic';
                const { mnemonic, xpub } = yield sdk.generateWallet(wrongMnemonic, {
                    testnet: true,
                });
                expect(mnemonic).toBe(wrongMnemonic);
                expect(xpub).toMatch(testData.TESTNET.XPUB_REGEX);
            }));
        });
    },
    generateAddressFromXpub: (sdk, testData) => {
        describe('mainnet', () => {
            it.each([
                [0, testData.MAINNET.ADDRESS_0],
                [100, testData.MAINNET.ADDRESS_100],
            ])('index %s', (idx, expectedAddress) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                const address = sdk.generateAddressFromXPub(testData.MAINNET.XPUB, idx);
                expect(address).toBe(expectedAddress);
            }));
            it.each([
                ['xpub', 'invalid xpub', 1, testData.INVALID_XPUB_ERROR],
                ['child index', testData.MAINNET.XPUB, -1, testData.INVALID_XPUB_CHILD_INDEX_ERROR],
            ])('invalid arg %s', (_, xpub, childIndex, errorMessage) => {
                expect(() => {
                    sdk.generateAddressFromXPub(xpub, childIndex);
                }).toThrow(errorMessage);
            });
        });
        describe('testnet', () => {
            it.each([
                [0, testData.TESTNET.ADDRESS_0],
                [100, testData.TESTNET.ADDRESS_100],
            ])('index %s', (idx, expectedAddress) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                const address = sdk.generateAddressFromXPub(testData.TESTNET.XPUB, idx, { testnet: true });
                expect(address).toBe(expectedAddress);
            }));
            it.each([
                ['xpub', 'invalid xpub', 1, testData.INVALID_XPUB_ERROR],
                ['child index', testData.TESTNET.XPUB, -1, testData.INVALID_XPUB_CHILD_INDEX_ERROR],
            ])('invalid arg %s', (_, xpub, childIndex, errorMessage) => {
                expect(() => {
                    sdk.generateAddressFromXPub(xpub, childIndex, { testnet: true });
                }).toThrow(errorMessage);
            });
        });
    },
    generatePrivateKeyFromMnemonic: (sdk, testData, givenMnemonic = shared_testing_1.TEST_DATA.MNEMONIC) => {
        describe('mainnet', () => {
            it('valid', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                const privateKey0 = yield sdk.generatePrivateKeyFromMnemonic(givenMnemonic, 0);
                expect(privateKey0).toBe(testData.MAINNET.PRIVATE_KEY_0);
                const privateKey100 = yield sdk.generatePrivateKeyFromMnemonic(givenMnemonic, 100);
                expect(privateKey100).toBe(testData.MAINNET.PRIVATE_KEY_100);
            }));
            it('invalid child index', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                yield expect(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return sdk.generatePrivateKeyFromMnemonic(givenMnemonic, -1); })).rejects.toThrow(testData.INVALID_PRIVATE_KEY_CHILD_INDEX_ERROR);
            }));
        });
        describe('testnet', () => {
            it('valid', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                const privateKey0 = yield sdk.generatePrivateKeyFromMnemonic(givenMnemonic, 0, { testnet: true });
                expect(privateKey0).toBe(testData.TESTNET.PRIVATE_KEY_0);
                const privateKey100 = yield sdk.generatePrivateKeyFromMnemonic(givenMnemonic, 100, {
                    testnet: true,
                });
                expect(privateKey100).toBe(testData.TESTNET.PRIVATE_KEY_100);
            }));
            it('invalid child index', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                yield expect(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return sdk.generatePrivateKeyFromMnemonic(givenMnemonic, -1, { testnet: true }); })).rejects.toThrow(testData.INVALID_PRIVATE_KEY_CHILD_INDEX_ERROR);
            }));
        });
    },
    generateAddressFromPrivateKey: (sdk, testData, options) => {
        describe('mainnet', () => {
            it('valid', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                const address0 = sdk.generateAddressFromPrivateKey(testData.MAINNET.PRIVATE_KEY_0);
                expect(address0).toBe(testData.MAINNET.ADDRESS_0);
                const address100 = sdk.generateAddressFromPrivateKey(testData.MAINNET.PRIVATE_KEY_100);
                expect(address100).toBe(testData.MAINNET.ADDRESS_100);
            }));
            if (!(options === null || options === void 0 ? void 0 : options.skipInvalid)) {
                it('invalid private key', () => {
                    expect(() => {
                        sdk.generateAddressFromPrivateKey('invalidKey');
                    }).toThrow(testData.INVALID_PRIVATE_KEY_ERROR);
                });
            }
        });
        describe('testnet', () => {
            it('testnet', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                const address0 = sdk.generateAddressFromPrivateKey(testData.TESTNET.PRIVATE_KEY_0, { testnet: true });
                expect(address0).toBe(testData.TESTNET.ADDRESS_0);
                const address100 = sdk.generateAddressFromPrivateKey(testData.TESTNET.PRIVATE_KEY_100, {
                    testnet: true,
                });
                expect(address100).toBe(testData.TESTNET.ADDRESS_100);
            }));
            if (!(options === null || options === void 0 ? void 0 : options.skipInvalid)) {
                it('invalid private key', () => {
                    expect(() => {
                        sdk.generateAddressFromPrivateKey('invalidKey', { testnet: true });
                    }).toThrow(testData.INVALID_PRIVATE_KEY_ERROR);
                });
            }
        });
    },
};
//# sourceMappingURL=wallet.test-factory.js.map