"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tronTrc721 = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@tatumio/api-client");
const shared_blockchain_evm_based_1 = require("@tatumio/shared-blockchain-evm-based");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const shared_core_1 = require("@tatumio/shared-core");
const prepareDeploySignedTransaction = (body, tronWeb, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const client = tronWeb.getClient(provider);
    const { name, symbol, feeLimit } = body;
    const params = {
        feeLimit: client.toSun(feeLimit),
        callValue: 0,
        userFeePercentage: 100,
        originEnergyLimit: 1,
        abi: JSON.stringify(shared_blockchain_evm_based_1.Trc721Token.abi),
        bytecode: shared_blockchain_evm_based_1.Trc721Token.bytecode,
        parameters: [name, symbol],
        name,
    };
    if (body.signatureId) {
        const tx = yield client.transactionBuilder.createSmartContract(params, body.from);
        return JSON.stringify(tx);
    }
    else {
        const tx = yield client.transactionBuilder.createSmartContract(params, client.address.fromPrivateKey(body.fromPrivateKey));
        return JSON.stringify(yield client.trx.sign(tx, body.fromPrivateKey));
    }
});
const prepareMintSignedTransaction = (body, tronWeb, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { url, to, tokenId, contractAddress, feeLimit } = body;
    const client = tronWeb.getClient(provider);
    client.setAddress(contractAddress);
    const contractAddressHex = client.address.toHex(contractAddress);
    const methodName = 'mintWithTokenURI(address,uint256,string)';
    const params = [
        { type: 'address', value: client.address.toHex(to) },
        {
            type: 'uint256',
            value: `0x${new bignumber_js_1.default(tokenId).toString(16)}`,
        },
        {
            type: 'string',
            value: url,
        },
    ];
    if (body.signatureId) {
        const { transaction } = yield client.transactionBuilder.triggerSmartContract(contractAddressHex, methodName, {
            feeLimit: client.toSun(feeLimit),
            from: body.from,
        }, params, body.from);
        return JSON.stringify(transaction);
    }
    else {
        const sender = client.address.fromHex(client.address.fromPrivateKey(body.fromPrivateKey));
        const { transaction } = yield client.transactionBuilder.triggerSmartContract(contractAddressHex, methodName, {
            feeLimit: client.toSun(feeLimit),
            from: sender,
        }, params, sender);
        return JSON.stringify(yield client.trx.sign(transaction, body.fromPrivateKey));
    }
});
// TODO: do a balance check before sending tx - https://app.clickup.com/t/24443045/TT-3496
const transferSignedTransaction = (body, tronWeb, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { to, tokenId, contractAddress, feeLimit } = body;
    const client = tronWeb.getClient(provider);
    const params = [
        { type: 'address', value: client.address.toHex(to) },
        {
            type: 'uint256',
            value: `0x${new bignumber_js_1.default(tokenId).toString(16)}`,
        },
    ];
    const contractAddressHex = client.address.toHex(contractAddress);
    const methodName = 'safeTransfer(address,uint256)';
    client.setAddress(contractAddress);
    if (body.signatureId) {
        const { transaction } = yield client.transactionBuilder.triggerSmartContract(contractAddressHex, methodName, {
            feeLimit: client.toSun(feeLimit),
            from: body.from,
            callValue: 0,
        }, params, body.from);
        return JSON.stringify(transaction);
    }
    else {
        const sender = client.address.fromHex(client.address.fromPrivateKey(body.fromPrivateKey));
        const { transaction } = yield client.transactionBuilder.triggerSmartContract(contractAddressHex, methodName, {
            feeLimit: client.toSun(feeLimit),
            from: sender,
            callValue: 0,
        }, params, sender);
        return JSON.stringify(yield client.trx.sign(transaction, body.fromPrivateKey));
    }
});
const burnSignedTransaction = (body, tronWeb, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { tokenId, contractAddress, feeLimit } = body;
    const client = tronWeb.getClient(provider);
    client.setAddress(contractAddress);
    const contractAddressHex = client.address.toHex(contractAddress);
    const methodName = 'burn(uint256)';
    const params = [
        {
            type: 'uint256',
            value: `0x${new bignumber_js_1.default(tokenId).toString(16)}`,
        },
    ];
    if (body.signatureId) {
        const { transaction } = yield client.transactionBuilder.triggerSmartContract(contractAddressHex, methodName, {
            feeLimit: client.toSun(feeLimit),
            from: body.from,
        }, params, body.from);
        return JSON.stringify(transaction);
    }
    else {
        const sender = client.address.fromHex(client.address.fromPrivateKey(body.fromPrivateKey));
        const { transaction } = yield client.transactionBuilder.triggerSmartContract(contractAddressHex, methodName, {
            feeLimit: client.toSun(feeLimit),
            from: sender,
        }, params, sender);
        return JSON.stringify(yield client.trx.sign(transaction, body.fromPrivateKey));
    }
});
const prepareMintMultipleSignedTransaction = (body, tronWeb, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { to, tokenId, contractAddress, url, feeLimit } = body;
    const client = tronWeb.getClient(provider);
    client.setAddress(contractAddress);
    const contractAddressHex = client.address.toHex(contractAddress);
    const methodName = 'mintMultiple(address[],uint256[],string[])';
    const params = [
        {
            type: 'address[]',
            value: to.map((a) => client.address.toHex(a)),
        },
        {
            type: 'uint256[]',
            value: tokenId.map((t) => `0x${new bignumber_js_1.default(t).toString(16)}`),
        },
        {
            type: 'string[]',
            value: url,
        },
    ];
    if (body.signatureId) {
        const { transaction } = yield client.transactionBuilder.triggerSmartContract(contractAddressHex, methodName, {
            feeLimit: client.toSun(feeLimit),
            from: body.from,
        }, params, body.from);
        return JSON.stringify(transaction);
    }
    else {
        const sender = client.address.fromHex(client.address.fromPrivateKey(body.fromPrivateKey));
        const { transaction } = yield client.transactionBuilder.triggerSmartContract(contractAddressHex, methodName, {
            feeLimit: client.toSun(feeLimit),
            from: sender,
        }, params, sender);
        return JSON.stringify(yield client.trx.sign(transaction, body.fromPrivateKey));
    }
});
const tronTrc721 = (args) => {
    return {
        prepare: {
            /**
             * Sign Tron deploy trc721 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider
             * @returns transaction data to be broadcast to blockchain.
             */
            deploySignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return prepareDeploySignedTransaction(body, args.tronWeb, provider); }),
            /**
             * Sign Tron deploy trc721 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider
             * @returns transaction data to be broadcast to blockchain.
             */
            mintSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return prepareMintSignedTransaction(body, args.tronWeb, provider); }),
            /**
             * Sign Tron transfer trc721 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider
             * @returns transaction data to be broadcast to blockchain.
             */
            transferSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return transferSignedTransaction(body, args.tronWeb, provider); }),
            /**
             * Sign Tron burn trc721 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider
             * @returns transaction data to be broadcast to blockchain.
             */
            burnSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return burnSignedTransaction(body, args.tronWeb, provider); }),
            /**
             * Sign Tron mint multiple trc721 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider
             * @returns transaction data to be broadcast to blockchain.
             */
            mintMultipleSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return prepareMintMultipleSignedTransaction(body, args.tronWeb, provider); }),
        },
        send: {
            /**
             * Send Tron deploy trc721 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @returns transaction id of the transaction in the blockchain
             */
            deploySignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftDeployErc721(Object.assign(Object.assign({}, body), { chain: shared_core_1.Blockchain.TRON }));
                }
                else {
                    return api_client_1.TronService.tronBroadcast({
                        txData: yield prepareDeploySignedTransaction(body, args.tronWeb, provider),
                    });
                }
            }),
            /**
             * Send Tron mint cashback trc721 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @returns transaction id of the transaction in the blockchain
             */
            mintSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftMintErc721(Object.assign(Object.assign({}, body), { chain: shared_core_1.Blockchain.TRON }));
                }
                else {
                    return api_client_1.TronService.tronBroadcast({
                        txData: yield prepareMintSignedTransaction(body, args.tronWeb, provider),
                    });
                }
            }),
            /**
             * Send Tron transfer trc721 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @returns transaction id of the transaction in the blockchain
             */
            transferSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftTransferErc721(Object.assign(Object.assign({}, body), { chain: shared_core_1.Blockchain.TRON }));
                }
                else {
                    return api_client_1.TronService.tronBroadcast({
                        txData: yield transferSignedTransaction(body, args.tronWeb, provider),
                    });
                }
            }),
            /**
             * Send Tron burn trc721 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @returns transaction id of the transaction in the blockchain
             */
            burnSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftBurnErc721(Object.assign(Object.assign({}, body), { chain: shared_core_1.Blockchain.TRON }));
                }
                else {
                    return api_client_1.TronService.tronBroadcast({
                        txData: yield burnSignedTransaction(body, args.tronWeb, provider),
                    });
                }
            }),
            /**
             * Send Tron mint multiple trc721 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @returns transaction id of the transaction in the blockchain
             */
            mintMultipleSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftMintMultipleErc721(Object.assign(Object.assign({}, body), { chain: shared_core_1.Blockchain.TRON }));
                }
                else {
                    return api_client_1.TronService.tronBroadcast({
                        txData: yield prepareMintMultipleSignedTransaction(body, args.tronWeb, provider),
                    });
                }
            }),
        },
    };
};
exports.tronTrc721 = tronTrc721;
//# sourceMappingURL=tron.trc721.js.map