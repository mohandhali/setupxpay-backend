"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isBase58 = exports.generateAddress = void 0;
const elliptic_1 = require("elliptic");
const js_sha3_1 = require("js-sha3");
const hexChar2byte = (c) => {
    let d = 0;
    if (c >= 'A' && c <= 'F')
        d = c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;
    else if (c >= 'a' && c <= 'f')
        d = c.charCodeAt(0) - 'a'.charCodeAt(0) + 10;
    else if (c >= '0' && c <= '9')
        d = c.charCodeAt(0) - '0'.charCodeAt(0);
    return d;
};
const isHexChar = (c) => {
    if ((c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f') || (c >= '0' && c <= '9')) {
        return 1;
    }
    return 0;
};
// TODO: should return Uint8Array
const hexStr2byteArray = (str) => {
    const byteArray = [];
    let d = 0;
    let j = 0;
    let k = 0;
    for (let i = 0; i < str.length; i++) {
        const c = str.charAt(i);
        if (isHexChar(c)) {
            d <<= 4;
            d += hexChar2byte(c);
            j++;
            if (0 === j % 2) {
                byteArray[k++] = d;
                d = 0;
            }
        }
    }
    return byteArray;
};
// @ts-ignore
const byte2hexStr = (byte) => {
    const hexByteMap = '0123456789ABCDEF';
    let str = '';
    str += hexByteMap.charAt(byte >> 4);
    str += hexByteMap.charAt(byte & 0x0f);
    return str;
};
const byteArray2hexStr = (byteArray) => {
    let str = '';
    for (const byte of byteArray) {
        str += byte2hexStr(byte);
    }
    return str;
};
const computeAddress = (pubBytes) => {
    if (pubBytes.length === 65)
        pubBytes = pubBytes.slice(1);
    const hash = (0, js_sha3_1.keccak_256)(pubBytes).toString();
    const addressHex = '41' + hash.substring(24);
    return hexStr2byteArray(addressHex);
};
const generatePubKey = (bytes) => {
    const ec = new elliptic_1.ec('secp256k1');
    const key = ec.keyFromPublic(bytes, 'bytes');
    const pubkey = key.getPublic();
    const x = pubkey.getX();
    const y = pubkey.getY();
    let xHex = x.toString('hex');
    while (xHex.length < 64) {
        xHex = '0' + xHex;
    }
    let yHex = y.toString('hex');
    while (yHex.length < 64) {
        yHex = '0' + yHex;
    }
    return '04' + xHex + yHex;
};
const generateAddress = (publicKey) => byteArray2hexStr(computeAddress(hexStr2byteArray(generatePubKey(publicKey))));
exports.generateAddress = generateAddress;
const isBase58 = (value) => /^[A-HJ-NP-Za-km-z1-9]*$/.test(value);
exports.isBase58 = isBase58;
//# sourceMappingURL=tron.utils.js.map