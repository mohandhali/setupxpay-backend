"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.virtualAccountService = exports.TrcType = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@tatumio/api-client");
const shared_blockchain_abstract_1 = require("@tatumio/shared-blockchain-abstract");
const shared_core_1 = require("@tatumio/shared-core");
const tron_wallet_1 = require("./tron.wallet");
const tron_tx_1 = require("./tron.tx");
var TrcType;
(function (TrcType) {
    TrcType["TRC10"] = "TRC10";
    TrcType["TRC20"] = "TRC20";
})(TrcType = exports.TrcType || (exports.TrcType = {}));
const TRON_BASED_CURRENCIES = [api_client_1.Currency.USDT_TRON.toString(), api_client_1.Currency.INRT_TRON.toString()];
const sendTronVirtualAccountTransaction = (body, tronWeb) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { mnemonic, index, fromPrivateKey } = body, withdrawal = tslib_1.__rest(body, ["mnemonic", "index", "fromPrivateKey"]);
    const { amount, address, senderAccountId } = withdrawal;
    const wallet = (0, tron_wallet_1.tronWallet)({ tronWeb });
    const txService = (0, tron_tx_1.tronTx)({ tronWeb });
    let fromPrivKey;
    let txData;
    if (mnemonic && index !== undefined) {
        fromPrivKey = (yield wallet.generatePrivateKeyFromMnemonic(mnemonic, index));
    }
    else {
        fromPrivKey = body.fromPrivateKey;
    }
    const withdrawalFee = (withdrawal === null || withdrawal === void 0 ? void 0 : withdrawal.fee) || '2.5';
    const withdrawalBody = Object.assign(Object.assign({}, withdrawal), { fee: withdrawalFee });
    const account = yield api_client_1.AccountService.getAccountByAccountId(senderAccountId);
    if (account.currency === api_client_1.Currency.TRON) {
        txData = yield txService.native.prepare.signedTransaction({
            amount,
            fromPrivateKey: fromPrivKey,
            to: address,
        });
    }
    else if (TRON_BASED_CURRENCIES.includes(account.currency)) {
        txData = yield txService.trc20.prepare.signedTransaction({
            amount,
            fromPrivateKey: fromPrivKey,
            to: address,
            tokenAddress: shared_core_1.CONTRACT_ADDRESSES[account.currency],
            feeLimit: parseFloat(withdrawalFee),
        });
    }
    else {
        const vc = yield api_client_1.VirtualCurrencyService.getCurrency(account.currency);
        if (vc.trcType === TrcType.TRC10) {
            txData = yield txService.trc10.prepare.signedTransaction({
                amount,
                fromPrivateKey: fromPrivKey,
                to: address,
                tokenId: vc.erc20Address,
            }, vc.precision);
        }
        else if (vc.trcType === TrcType.TRC20) {
            txData = yield txService.trc20.prepare.signedTransaction({
                amount,
                feeLimit: parseFloat(withdrawalFee),
                fromPrivateKey: fromPrivKey,
                to: address,
                tokenAddress: vc.erc20Address,
            });
        }
        else {
            throw new Error('Unsupported account.');
        }
    }
    const { id } = yield api_client_1.WithdrawalService.storeWithdrawal(withdrawalBody);
    try {
        return Object.assign(Object.assign({}, (yield api_client_1.WithdrawalService.broadcastBlockchainTransaction({
            txData,
            withdrawalId: id,
            currency: api_client_1.Currency.TRON,
        }))), { id });
    }
    catch (e) {
        console.error(e);
        try {
            return yield api_client_1.WithdrawalService.cancelInProgressWithdrawal(id);
        }
        catch (e1) {
            console.log(e);
            return { id };
        }
    }
});
const virtualAccountService = (args) => {
    return Object.assign(Object.assign({}, (0, shared_blockchain_abstract_1.abstractBlockchainVirtualAccount)(args)), { 
        /**
         * Send Tron transaction from Tatum Ledger account to the blockchain. This method broadcasts signed transaction to the blockchain.
         * This operation is irreversible.
         * @param body content of the transaction to broadcast
         * @returns transaction id of the transaction in the blockchain or id of the withdrawal, if it was not cancelled automatically
         */
        send: (body) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            if (body.signatureId) {
                return api_client_1.ApiServices.virtualAccount.blockchain.tronTransferOffchain(body);
            }
            else {
                return yield sendTronVirtualAccountTransaction(body, args.tronWeb);
            }
        }) });
};
exports.virtualAccountService = virtualAccountService;
//# sourceMappingURL=tron.virtualAccount.js.map