"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tronWallet = void 0;
const tslib_1 = require("tslib");
const shared_core_1 = require("@tatumio/shared-core");
const bip32_1 = require("bip32");
const bip39_1 = require("bip39");
const tron_utils_1 = require("./tron.utils");
// tronweb lib dont have any typings (not even in @types)
// @ts-ignore
const tronweb_1 = tslib_1.__importDefault(require("tronweb"));
const tron_custodial_1 = require("./tron.custodial");
const tron_gasPump_1 = require("./tron.gasPump");
const web3_utils_1 = require("web3-utils");
const generateBlockchainWallet = (mnem) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const w = (0, bip32_1.fromSeed)(yield (0, bip39_1.mnemonicToSeed)(mnem));
    const bip32Interface = w.derivePath(shared_core_1.DERIVATION_PATH[shared_core_1.Blockchain.TRON]).neutered();
    return {
        mnemonic: mnem,
        xpub: bip32Interface.toBase58(),
    };
});
const tronWallet = (args) => {
    return {
        /**
         * Generate Tron wallet
         * @returns mnemonic for the wallet
         */
        generateBlockchainWallet,
        /**
         * Generate wallet
         * @param mnemonic optional mnemonic seed to use. If not present, new one will be generated
         * @returns wallet or a combination of address and private key
         */
        generateWallet(mnemonic) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return generateBlockchainWallet(mnemonic !== null && mnemonic !== void 0 ? mnemonic : (0, bip39_1.generateMnemonic)(256));
            });
        },
        /**
         * Generate address
         * @param xpub extended public key to generate address from
         * @param i derivation index of address to generate. Up to 2^31 addresses can be generated.
         * @returns blockchain address
         */
        generateAddressFromXPub(xpub, i) {
            let w;
            if (xpub.length === 130 && (0, web3_utils_1.isHex)(xpub)) {
                w = (0, bip32_1.fromPublicKey)(Buffer.from(xpub.slice(0, 66), 'hex'), Buffer.from(xpub.slice(-64), 'hex'));
            }
            else if (xpub.length === 111 && (0, tron_utils_1.isBase58)(xpub)) {
                w = (0, bip32_1.fromBase58)(xpub);
            }
            else {
                throw new Error('Unknown xpub format');
            }
            return tronweb_1.default.address.fromHex((0, tron_utils_1.generateAddress)(w.derive(i).publicKey));
        },
        /**
         * Generate private key from mnemonic seed
         * @param mnemonic mnemonic to generate private key from
         * @param i derivation index of private key to generate.
         * @returns blockchain private key to the address
         */
        generatePrivateKeyFromMnemonic(mnemonic, i) {
            var _a, _b;
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return ((_b = (_a = (0, bip32_1.fromSeed)(yield (0, bip39_1.mnemonicToSeed)(mnemonic))
                    .derivePath(shared_core_1.DERIVATION_PATH[shared_core_1.Blockchain.TRON])
                    .derive(i)
                    .privateKey) === null || _a === void 0 ? void 0 : _a.toString('hex')) !== null && _b !== void 0 ? _b : '');
            });
        },
        /**
         * Generate address from private key
         * @param privateKey private key to use
         * @returns blockchain private key to the address
         */
        generateAddressFromPrivatekey(privateKey) {
            return tronweb_1.default.address.fromPrivateKey(privateKey);
        },
        custodial: (0, tron_custodial_1.tronCustodial)(args),
        gasPump: (0, tron_gasPump_1.tronGasPump)(args),
    };
};
exports.tronWallet = tronWallet;
//# sourceMappingURL=tron.wallet.js.map