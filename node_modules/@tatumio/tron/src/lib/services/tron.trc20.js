"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tronTrc20 = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@tatumio/api-client");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const shared_blockchain_evm_based_1 = require("@tatumio/shared-blockchain-evm-based");
const prepareSignedTransaction = (body, tronWeb, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { to, tokenAddress, amount, feeLimit } = body;
    const client = tronWeb.getClient(provider);
    client.setAddress(tokenAddress);
    const contractInstance = yield client.contract(shared_blockchain_evm_based_1.Trc20Token.abi, tokenAddress);
    const from = body.signatureId
        ? body.from
        : client.address.fromHex(client.address.fromPrivateKey(body.fromPrivateKey));
    const balance = (yield contractInstance.balanceOf(from).call()).toString();
    const decimals = yield contractInstance.decimals().call({ _isConstant: true });
    const valueToSend = new bignumber_js_1.default(amount).multipliedBy(new bignumber_js_1.default(10).pow(decimals));
    if (valueToSend.isGreaterThan(new bignumber_js_1.default(balance || 0))) {
        throw new Error('Insufficient TRC20 balance');
    }
    const tokenAddressHex = client.address.toHex(tokenAddress);
    const methodName = 'transfer(address,uint256)';
    const params = [
        { type: 'address', value: client.address.toHex(to) },
        {
            type: 'uint256',
            value: `0x${new bignumber_js_1.default(amount).multipliedBy(new bignumber_js_1.default(10).pow(decimals)).toString(16)}`,
        },
    ];
    const feeLimitSun = client.toSun(feeLimit);
    if (body.signatureId) {
        const { transaction } = yield client.transactionBuilder.triggerSmartContract(tokenAddressHex, methodName, {
            feeLimit: feeLimitSun,
            from,
        }, params, from);
        return JSON.stringify(transaction);
    }
    else {
        const { transaction } = yield client.transactionBuilder.triggerSmartContract(tokenAddressHex, methodName, {
            feeLimit: feeLimitSun,
            from,
        }, params, from);
        return JSON.stringify(yield client.trx.sign(transaction, body.fromPrivateKey));
    }
});
const prepareCreateSignedTransaction = (body, tronWeb, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { name, decimals, recipient, symbol, totalSupply } = body;
    const client = tronWeb.getClient(provider);
    const params = {
        feeLimit: 1000000000,
        callValue: 0,
        userFeePercentage: 100,
        originEnergyLimit: 1,
        abi: JSON.stringify(shared_blockchain_evm_based_1.Trc20Token.abi),
        bytecode: shared_blockchain_evm_based_1.Trc20Token.bytecode,
        parameters: [name, symbol, client.address.toHex(recipient), decimals, totalSupply, totalSupply],
        name,
    };
    if (body.signatureId) {
        const tx = yield client.transactionBuilder.createSmartContract(params, body.from);
        return JSON.stringify(tx);
    }
    else {
        const tx = yield client.transactionBuilder.createSmartContract(params, client.address.fromPrivateKey(body.fromPrivateKey));
        return JSON.stringify(yield client.trx.sign(tx, body.fromPrivateKey));
    }
});
const tronTrc20 = (args) => {
    return {
        // TODO: return any?
        /**
         * Get TRC20 balance for the given tron address.
         * @param address the address whose balance is returned
         * @param contractAddress the TRC20 contract address
         * @param provider
         */
        getAccountTrc20Address: (address, contractAddress, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const client = args.tronWeb.getClient(provider);
            client.setAddress(contractAddress);
            const contractInstance = yield client.contract().at(contractAddress);
            return contractInstance.balanceOf(address).call();
        }),
        // TODO: return any?
        getTrc20ContractDecimals: (contractAddress, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const client = args.tronWeb.getClient(provider);
            client.setAddress(contractAddress);
            const contractInstance = yield client.contract().at(contractAddress);
            return contractInstance.decimals().call();
        }),
        prepare: {
            /**
             * Sign create Tron TRC20 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @returns transaction data to be broadcast to blockchain.
             */
            signedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return prepareSignedTransaction(body, args.tronWeb, provider); }),
            /**
             * Prepare create Tron TRC20 transaction for KMS. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider
             * @returns transaction data to be broadcast to blockchain.
             */
            createSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return prepareCreateSignedTransaction(body, args.tronWeb, provider); }),
        },
        send: {
            /**
             * Send Tron TRC20 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @returns transaction id of the transaction in the blockchain
             */
            signedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.TronService.tronTransferTrc20(body);
                }
                else {
                    return api_client_1.TronService.tronBroadcast({
                        txData: yield prepareSignedTransaction(body, args.tronWeb, provider),
                    });
                }
            }),
            /**
             * Create Tron TRC20 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @returns transaction id of the transaction in the blockchain
             */
            createSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.TronService.tronCreateTrc20(body);
                }
                else {
                    return api_client_1.TronService.tronBroadcast({
                        txData: yield prepareCreateSignedTransaction(body, args.tronWeb, provider),
                    });
                }
            }),
        },
    };
};
exports.tronTrc20 = tronTrc20;
//# sourceMappingURL=tron.trc20.js.map