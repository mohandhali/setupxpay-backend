"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tronCustodial = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@tatumio/api-client");
const tron_tx_1 = require("./tron.tx");
const shared_blockchain_evm_based_1 = require("@tatumio/shared-blockchain-evm-based");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const shared_core_1 = require("@tatumio/shared-core");
// @ts-ignore
const tronweb_1 = tslib_1.__importDefault(require("tronweb"));
const NATIVE_ASSET_CONTRACT_TYPE = 3;
const NON_FUNGIBLE_TOKEN_CONTRACT_TYPE = 1;
const FUNGIBLE_TOKEN_CONTRACT_TYPE = 0;
const convertAddressToHex = (address) => tronweb_1.default.address.toHex(address);
const prepareTransferFromCustodialWallet = (body, getContractDecimals, tronWeb, provider, decimals = 6, testnet = false) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const methodName = 'transfer(address,uint256,address,uint256,uint256)';
    let tokenId = new bignumber_js_1.default((_a = body.tokenId) !== null && _a !== void 0 ? _a : 0);
    let amount = new bignumber_js_1.default((_b = body.amount) !== null && _b !== void 0 ? _b : 0);
    if (body.contractType === NATIVE_ASSET_CONTRACT_TYPE) {
        amount = amount.multipliedBy(new bignumber_js_1.default(10).pow(decimals));
    }
    else if (body.contractType === FUNGIBLE_TOKEN_CONTRACT_TYPE) {
        tokenId = new bignumber_js_1.default(0);
        if (!body.tokenAddress) {
            throw new Error('No tokenAddress specified which is needed for FUNGIBLE_TOKEN_CONTRACT_TYPE');
        }
        amount = amount.multipliedBy(new bignumber_js_1.default(10).pow(yield getContractDecimals(body.tokenAddress, provider, testnet)));
    }
    const fee = {
        gasLimit: body.feeLimit.toString(),
        gasPrice: '0',
    };
    const { tokenAddress, contractType, recipient } = body;
    const params = Object.assign(Object.assign({}, body), { methodName, contractAddress: body.custodialAddress, methodABI: shared_blockchain_evm_based_1.CustodialFullTokenWallet.abi.find((abi) => abi.name === methodName), params: [
            {
                type: 'address',
                value: convertAddressToHex(tokenAddress || '0x000000000000000000000000000000000000dEaD'),
            },
            { type: 'uint256', value: contractType },
            { type: 'address', value: convertAddressToHex(recipient) },
            { type: 'uint256', value: `0x${amount.toString(16)}` },
            { type: 'uint256', value: `0x${new bignumber_js_1.default(tokenId).toString(16)}` },
        ], fee });
    return (0, tron_tx_1.tronTx)({ tronWeb }).smartContract.prepare.smartContractInvocation(params, provider);
});
const prepareBatchTransferFromCustodialWallet = (body, getContractDecimals, tronWeb, provider, decimals = 6, testnet = false) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const methodName = 'transferBatch';
    const amounts = [];
    const tokenIds = [];
    for (let i = 0; i < body.contractType.length; i++) {
        let amount = new bignumber_js_1.default(body.amount ? body.amount[i] : 0);
        let tokenId = new bignumber_js_1.default(body.tokenId ? body.tokenId[i] : 0);
        if (body.contractType[i] === NATIVE_ASSET_CONTRACT_TYPE) {
            amount = amount.multipliedBy(new bignumber_js_1.default(10).pow(decimals));
        }
        else if (body.contractType[i] === NON_FUNGIBLE_TOKEN_CONTRACT_TYPE) {
            amount = new bignumber_js_1.default(0);
        }
        else if (body.contractType[i] === FUNGIBLE_TOKEN_CONTRACT_TYPE && body.tokenAddress) {
            tokenId = new bignumber_js_1.default(0);
            amount = amount.multipliedBy(new bignumber_js_1.default(10).pow(yield getContractDecimals(body.tokenAddress[i], provider, testnet)));
        }
        amounts.push(`0x${amount.toString(16)}`);
        tokenIds.push(`0x${tokenId.toString(16)}`);
    }
    const params = Object.assign(Object.assign({}, body), { amount: undefined, methodName, contractAddress: body.custodialAddress, methodABI: shared_blockchain_evm_based_1.CustodialFullTokenWallet.abi.find((abi) => abi.name === methodName), params: [
            (body.tokenAddress || []).map((t) => (t === '0' ? '0x000000000000000000000000000000000000dEaD' : t)),
            body.contractType,
            body.recipient,
            amounts,
            tokenIds,
        ] });
    return (0, tron_tx_1.tronTx)({ tronWeb }).smartContract.prepare.smartContractInvocation(params, provider);
});
const tronCustodial = (args) => {
    return {
        prepare: {
            /**
             * This method is @Deprecated. Use @link{prepareCustodialWalletBatch} instead
             * Generate new smart contract based custodial wallet. This wallet is able to receive any type of assets, btu transaction costs connected to the withdrawal
             * of assets is covered by the deployer.
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            custodialWallet: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return (0, tron_tx_1.tronTx)(args).custodial.prepare.generateCustodialWalletSignedTransaction(body, provider); }),
            /**
             * Prepare signed transaction from the custodial SC wallet.
             * @param testnet chain to work with
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            transferFromCustodialWallet: (body, getContractDecimals, provider, decimals = 6, testnet = false) => prepareTransferFromCustodialWallet(body, getContractDecimals, args.tronWeb, provider, decimals, testnet),
            /**
             * Prepare signed batch transaction from the custodial SC wallet.
             * @param testnet chain to work with
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            batchTransferFromCustodialWallet: (body, getContractDecimals, provider, decimals = 6, testnet = false) => prepareBatchTransferFromCustodialWallet(body, getContractDecimals, args.tronWeb, provider, decimals, testnet),
        },
        send: {
            /**
             * Send signed transaction from the custodial SC wallet.
             * @param testnet chain to work with
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            transferFromCustodialWallet: (body, getContractDecimals, provider, decimals = 6, testnet = false) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.GasPumpService.transferCustodialWallet(Object.assign(Object.assign({}, body), { chain: shared_core_1.Blockchain.TRON }));
                }
                else {
                    return api_client_1.TronService.tronBroadcast({
                        txData: yield prepareTransferFromCustodialWallet(body, getContractDecimals, args.tronWeb, provider, decimals, testnet),
                    });
                }
            }),
            /**
             * Send signed batch transaction from the custodial SC wallet.
             * @param testnet chain to work with
             * @param body request data
             * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
             * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
             */
            batchTransferFromCustodialWallet: (body, getContractDecimals, provider, decimals = 6, testnet = false) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.GasPumpService.transferCustodialWalletBatch(Object.assign(Object.assign({}, body), { chain: shared_core_1.Blockchain.TRON }));
                }
                else {
                    return api_client_1.TronService.tronBroadcast({
                        txData: yield prepareBatchTransferFromCustodialWallet(body, getContractDecimals, args.tronWeb, provider, decimals, testnet),
                    });
                }
            }),
        },
    };
};
exports.tronCustodial = tronCustodial;
//# sourceMappingURL=tron.custodial.js.map