"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tronTrc10 = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@tatumio/api-client");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
// TODO: do a balance check before sending tx - https://app.clickup.com/t/24443045/TT-3496
const prepareSignedTransaction = (body, tronWeb, precision, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { to, tokenId, amount } = body;
    const client = tronWeb.getClient(provider);
    const definedPrecision = precision !== null && precision !== void 0 ? precision : (yield api_client_1.TronService.tronTrc10Detail(tokenId)).precision;
    if (!definedPrecision) {
        throw new Error('Unable to obtain precision');
    }
    if (body.signatureId) {
        const tx = yield client.transactionBuilder.sendToken(to, new bignumber_js_1.default(amount).multipliedBy(new bignumber_js_1.default(10).pow(definedPrecision)), tokenId, body.from);
        return JSON.stringify(tx);
    }
    else {
        const tx = yield client.transactionBuilder.sendToken(to, new bignumber_js_1.default(amount).multipliedBy(new bignumber_js_1.default(10).pow(definedPrecision)), tokenId, client.address.fromHex(client.address.fromPrivateKey(body.fromPrivateKey)));
        return JSON.stringify(yield client.trx.sign(tx, body.fromPrivateKey));
    }
});
const prepareCreateSignedTransaction = (body, tronWeb, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { name, abbreviation, description, url, totalSupply, decimals } = body;
    const client = tronWeb.getClient(provider);
    const createTokenParams = {
        name,
        abbreviation,
        description,
        url,
        totalSupply: new bignumber_js_1.default(totalSupply).multipliedBy(new bignumber_js_1.default(10).pow(decimals)),
        trxRatio: 1,
        tokenRatio: 1,
        saleStart: Date.now() + 60000,
        saleEnd: Date.now() + 100000,
        freeBandwidth: 0,
        freeBandwidthLimit: 0,
        frozenAmount: 0,
        frozenDuration: 0,
        precision: decimals,
    };
    if (body.signatureId) {
        const tx = yield client.transactionBuilder.createToken(createTokenParams, body.from);
        return JSON.stringify(tx);
    }
    else {
        const tx = yield client.transactionBuilder.createToken(createTokenParams, client.address.fromPrivateKey(body.fromPrivateKey));
        return JSON.stringify(yield client.trx.sign(tx, body.fromPrivateKey));
    }
});
const tronTrc10 = (args) => {
    return {
        prepare: {
            /**
             * Sign Tron TRC10 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param testnet mainnet or testnet version
             * @param body content of the transaction to broadcast
             * @param precision
             * @returns transaction data to be broadcast to blockchain.
             */
            signedTransaction: (body, precision, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return prepareSignedTransaction(body, args.tronWeb, precision, provider); }),
            /**
             * Sign create Tron TRC10 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @returns transaction data to be broadcast to blockchain.
             */
            createSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return prepareCreateSignedTransaction(body, args.tronWeb, provider); }),
        },
        send: {
            /**
             * Send Tron TRC10 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param testnet mainnet or testnet version
             * @param body content of the transaction to broadcast
             * @returns transaction id of the transaction in the blockchain
             */
            signedTransaction: (body, precision, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.TronService.tronTransferTrc10(body);
                }
                else {
                    return api_client_1.TronService.tronBroadcast({
                        txData: yield prepareSignedTransaction(body, args.tronWeb, precision, provider),
                    });
                }
            }),
            /**
             * Create Tron TRC10 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @returns transaction id of the transaction in the blockchain
             */
            createSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.TronService.tronCreateTrc10(body);
                }
                else {
                    return api_client_1.TronService.tronBroadcast({
                        txData: yield prepareCreateSignedTransaction(body, args.tronWeb, provider),
                    });
                }
            }),
        },
    };
};
exports.tronTrc10 = tronTrc10;
//# sourceMappingURL=tron.trc10.js.map