"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tronTx = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@tatumio/api-client");
const shared_blockchain_evm_based_1 = require("@tatumio/shared-blockchain-evm-based");
const tron_trc10_1 = require("./tron.trc10");
const tron_trc20_1 = require("./tron.trc20");
const tron_trc721_1 = require("./tron.trc721");
// TODO: do a balance check before sending tx - https://app.clickup.com/t/24443045/TT-3496
const prepareSignedTransaction = (body, tronWeb, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { to, amount } = body;
    const client = tronWeb.getClient(provider);
    if (body.signatureId) {
        const tx = yield client.transactionBuilder.sendTrx(to, client.toSun(amount), body.from);
        return JSON.stringify(tx);
    }
    else {
        const tx = yield client.transactionBuilder.sendTrx(to, client.toSun(amount), client.address.fromHex(client.address.fromPrivateKey(body.fromPrivateKey)));
        return JSON.stringify(yield client.trx.sign(tx, body.fromPrivateKey));
    }
});
const prepareFreezeTransaction = (body, tronWeb, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { amount, resource } = body;
    const client = tronWeb.getClient(provider);
    if (body.signatureId) {
        const tx = yield client.transactionBuilder.freezeBalanceV2(client.toSun(parseFloat(amount)), resource, body.from);
        return JSON.stringify(tx);
    }
    else {
        const tx = yield client.transactionBuilder.freezeBalanceV2(client.toSun(parseFloat(amount)), resource, client.address.fromHex(client.address.fromPrivateKey(body.fromPrivateKey)));
        return JSON.stringify(yield client.trx.sign(tx, body.fromPrivateKey));
    }
});
const prepareUnfreezeTransaction = (body, tronWeb, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { amount, resource } = body;
    const client = tronWeb.getClient(provider);
    if (body.signatureId) {
        const tx = yield client.transactionBuilder.unfreezeBalanceV2(client.toSun(parseFloat(amount)), resource, body.from);
        return JSON.stringify(tx);
    }
    else {
        const tx = yield client.transactionBuilder.unfreezeBalanceV2(client.toSun(parseFloat(amount)), resource, client.address.fromHex(client.address.fromPrivateKey(body.fromPrivateKey)));
        return JSON.stringify(yield client.trx.sign(tx, body.fromPrivateKey));
    }
});
const prepareSmartContractInvocation = (body, tronWeb, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const { amount, contractAddress, methodName, params } = body;
    const client = tronWeb.getClient(provider);
    client.setAddress(contractAddress);
    const contractAddressHex = client.address.toHex(contractAddress);
    const sender = body.signatureId
        ? body === null || body === void 0 ? void 0 : body.from
        : client.address.fromHex(client.address.fromPrivateKey(body.fromPrivateKey));
    const { transaction } = yield client.transactionBuilder.triggerSmartContract(contractAddressHex, methodName, {
        feeLimit: client.toSun((_a = body.fee) === null || _a === void 0 ? void 0 : _a.gasLimit),
        from: sender,
        callValue: client.toSun(amount || 0),
    }, params, sender);
    if (body.signatureId) {
        return JSON.stringify(transaction);
    }
    return JSON.stringify(yield client.trx.sign(transaction, body.fromPrivateKey));
});
const prepareGasPumpBatch = (body, tronWeb, provider, testnet) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const indexes = (0, shared_blockchain_evm_based_1.indexesFromRange)(body.from, body.to);
    const client = tronWeb.getClient(provider);
    const params = [
        { type: 'address', value: client.address.toHex(body.owner.trim()) },
        { type: 'uint256[]', value: indexes },
    ];
    const methodName = 'createBatch(address,uint256[])';
    const contractAddress = client.address.toHex((0, shared_blockchain_evm_based_1.evmBasedGasPump)().getGasPumpFactoryContractAddress('TRON', testnet));
    client.setAddress(contractAddress);
    const sender = body.signatureId
        ? client.address.fromHex(body.owner)
        : client.address.fromHex(client.address.fromPrivateKey(body.fromPrivateKey));
    const { transaction } = yield client.transactionBuilder.triggerSmartContract(contractAddress, methodName, {
        feeLimit: body.feeLimit ? client.toSun(body.feeLimit) : client.toSun(0),
        from: sender,
        callValue: client.toSun(0),
    }, params, sender);
    if (body.signatureId) {
        return JSON.stringify(transaction);
    }
    return JSON.stringify(yield client.trx.sign(transaction, body.fromPrivateKey));
});
const prepareCustodialTransferBatch = (body, tronWeb, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { contractAddress, fee } = body;
    const client = tronWeb.getClient(provider);
    client.setAddress(contractAddress);
    const contractAddressHex = client.address.toHex(contractAddress);
    const sender = body.signatureId
        ? body === null || body === void 0 ? void 0 : body.from
        : client.address.fromHex(client.address.fromPrivateKey(body.fromPrivateKey));
    const methodName = 'transferBatch(address[],uint256[],address[],uint256[],uint256[])';
    const { transaction } = yield client.transactionBuilder.triggerSmartContract(contractAddressHex, methodName, {
        feeLimit: client.toSun(fee === null || fee === void 0 ? void 0 : fee.gasLimit),
        from: sender,
    }, [
        { type: 'address[]', value: body.params[0].map(client.address.toHex) },
        { type: 'uint256[]', value: body.params[1] },
        { type: 'address[]', value: body.params[2].map(client.address.toHex) },
        { type: 'uint256[]', value: body.params[3] },
        { type: 'uint256[]', value: body.params[4] },
    ], sender);
    if (body.signatureId) {
        return JSON.stringify(transaction);
    }
    return JSON.stringify(yield client.trx.sign(transaction, body.fromPrivateKey));
});
const prepareGenerateCustodialWalletSignedTransaction = (body, tronWeb, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const client = tronWeb.getClient(provider);
    // TODO: implement obtainCustodialAddressType
    const { abi, code } = {};
    const sender = body.signatureId ? body.from : client.address.fromPrivateKey(body.fromPrivateKey);
    const tx = yield client.transactionBuilder.createSmartContract({
        feeLimit: client.toSun(body.feeLimit || 100),
        callValue: 0,
        userFeePercentage: 100,
        originEnergyLimit: 1,
        abi: JSON.stringify(abi),
        bytecode: code,
        parameters: [],
        name: 'CustodialWallet',
    }, sender);
    if (body.signatureId) {
        return JSON.stringify(tx);
    }
    return JSON.stringify(yield client.trx.sign(tx, body.fromPrivateKey));
});
const tronTx = (args) => {
    return {
        trc10: (0, tron_trc10_1.tronTrc10)(args),
        trc20: (0, tron_trc20_1.tronTrc20)(args),
        trc721: (0, tron_trc721_1.tronTrc721)(args),
        native: {
            prepare: {
                /**
                 * Sign Tron transaction with private keys locally. Nothing is broadcast to the blockchain.
                 * @param body content of the transaction to broadcast
                 * @param provider
                 * @returns transaction data to be broadcast to blockchain.
                 */
                signedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return prepareSignedTransaction(body, args.tronWeb, provider); }),
                /**
                 * Sign Tron Freeze balance V2 transaction with private keys locally. Nothing is broadcast to the blockchain.
                 * @param body content of the transaction to broadcast
                 * @param provider optional provider to enter. if not present, Tatum provider will be used.
                 * @returns transaction data to be broadcast to blockchain.
                 */
                freezeTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return prepareFreezeTransaction(body, args.tronWeb, provider); })
                /**
                 * Sign Tron Unfreeze balance V2 transaction with private keys locally. Nothing is broadcast to the blockchain.
                 * @param body content of the transaction to broadcast
                 * @param provider optional provider to enter. if not present, Tatum provider will be used.
                 * @returns transaction data to be broadcast to blockchain.
                 */ ,
                unfreezeTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return prepareUnfreezeTransaction(body, args.tronWeb, provider); }),
            },
            send: {
                /**
                 * Send Tron transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
                 * This operation is irreversible.
                 * @param body content of the transaction to broadcast
                 * @param provider optional provider to enter. if not present, Tatum provider will be used.
                 * @returns transaction id of the transaction in the blockchain
                 */
                signedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                    if (body.signatureId) {
                        return api_client_1.ApiServices.blockchain.tron.tronTransfer(body);
                    }
                    else {
                        return api_client_1.TronService.tronBroadcast({
                            txData: yield prepareSignedTransaction(body, args.tronWeb, provider),
                        });
                    }
                }),
                /**
                 * Send Tron Unfreeze balance V2 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
                 * This operation is irreversible.
                 * @param body content of the transaction to broadcast
                 * @param provider
                 * @returns transaction id of the transaction in the blockchain
                 */
                freezeTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                    if (body.signatureId) {
                        return api_client_1.ApiServices.blockchain.tron.tronFreeze(body);
                    }
                    else {
                        return api_client_1.TronService.tronBroadcast({
                            txData: yield prepareFreezeTransaction(body, args.tronWeb, provider),
                        });
                    }
                })
                /**
                 * Send Tron Unfreeze balance V2 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
                 * This operation is irreversible.
                 * @param body content of the transaction to broadcast
                 * @param provider
                 * @returns transaction id of the transaction in the blockchain
                 */ ,
                unfreezeTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                    if (body.signatureId) {
                        return api_client_1.ApiServices.blockchain.tron.tronUnfreeze(body);
                    }
                    else {
                        return api_client_1.TronService.tronBroadcast({
                            txData: yield prepareUnfreezeTransaction(body, args.tronWeb, provider),
                        });
                    }
                }),
            },
        },
        smartContract: {
            prepare: {
                /**
                 * Sign Tron custodial transfer transaction with private keys locally. Nothing is broadcast to the blockchain.
                 * @param body content of the transaction to broadcast
                 * @param provider
                 * @returns transaction data to be broadcast to blockchain.
                 */
                smartContractInvocation: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return prepareSmartContractInvocation(body, args.tronWeb, provider); }),
            },
        },
        custodial: {
            prepare: {
                /**
                 * Sign Tron custodial transfer batch transaction with private keys locally. Nothing is broadcast to the blockchain.
                 * @param body content of the transaction to broadcast
                 * @param provider
                 * @returns transaction data to be broadcast to blockchain.
                 */
                custodialTransferBatch: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return prepareCustodialTransferBatch(body, args.tronWeb, provider); }),
                /**
                 * Sign Tron generate custodial wallet transaction with private keys locally. Nothing is broadcast to the blockchain.
                 * @param body content of the transaction to broadcast
                 * @param provider
                 * @returns transaction data to be broadcast to blockchain.
                 */
                generateCustodialWalletSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return prepareGenerateCustodialWalletSignedTransaction(body, args.tronWeb, provider); }),
            },
        },
        gasPump: {
            prepare: {
                prepareGasPumpBatch: (testnet, body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return prepareGasPumpBatch(body, args.tronWeb, provider, testnet); }),
            },
        },
    };
};
exports.tronTx = tronTx;
//# sourceMappingURL=tron.tx.js.map