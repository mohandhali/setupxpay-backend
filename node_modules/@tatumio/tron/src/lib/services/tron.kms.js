"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tronKmsService = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@tatumio/api-client");
const shared_blockchain_abstract_1 = require("@tatumio/shared-blockchain-abstract");
const tron_web_1 = require("./tron.web");
const shared_blockchain_evm_based_1 = require("@tatumio/shared-blockchain-evm-based");
const shared_abstract_sdk_1 = require("@tatumio/shared-abstract-sdk");
const tronKmsService = (args) => {
    return Object.assign(Object.assign({}, (0, shared_blockchain_abstract_1.abstractBlockchainKms)(args)), { 
        /**
         * Sign pending transaction from Tatum KMS
         * @param tx pending transaction from KMS
         * @param fromPrivateKey private key to sign transaction with.
         * @param provider url of the blockchain server to connect to. If not set, default public server will be used.
         * @returns transaction data to be broadcast to blockchain.
         */
        sign(tx, fromPrivateKey, provider) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (tx.chain !== api_client_1.Currency.TRON) {
                    throw new shared_blockchain_evm_based_1.EvmBasedSdkError({ code: shared_abstract_sdk_1.SdkErrorCode.KMS_CHAIN_MISMATCH });
                }
                const client = (0, tron_web_1.tronWeb)().getClient(provider);
                const transactionConfig = JSON.parse(tx.serializedTransaction);
                return JSON.stringify(yield client.trx.sign(transactionConfig, fromPrivateKey));
            });
        } });
};
exports.tronKmsService = tronKmsService;
//# sourceMappingURL=tron.kms.js.map